/**
 * @file can1.h
 *
 * @brief This header file was generated by cantools version 40.2.1 Tue Sep 23 19:59:41 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef CAN1_H
#define CAN1_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CAN1_AMS_STATUS_1_FRAME_ID (0x20u)
#define CAN1_AMS_STATE_FRAME_ID (0x1fu)
#define CAN1_AMS_ERROR_FRAME_ID (0x1eu)
#define CAN1_DV_DRIVING_DYNAMICS_1_FRAME_ID (0x500u)
#define CAN1_DV_DRIVING_DYNAMICS_2_FRAME_ID (0x501u)
#define CAN1_DV_SYSTEM_STATUS_FRAME_ID (0x502u)
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_FRAME_ID (0x50cu)
#define CAN1_MCU_SET_DBU_INDICATOR_POINTS_FRAME_ID (0x50du)
#define CAN1_RES_STATUS_FRAME_ID (0x191u)
#define CAN1_RES_INITIALIZATION_FRAME_ID (0x711u)
#define CAN1_RES_NMT_NODE_CONTROL_FRAME_ID (0x00u)
#define CAN1_SWU_STATUS_FRAME_ID (0x38u)
#define CAN1_DBU_STATUS_1_FRAME_ID (0x40u)
#define CAN1_LV_POWER_SIGNAL_FRAME_ID (0x63u)
#define CAN1_LV_BMS_DATA_A_FRAME_ID (0x64u)
#define CAN1_LV_BMS_STATUS_A_FRAME_ID (0x65u)
#define CAN1_AMS_TEMPERATURES_FRAME_ID (0x24u)
#define CAN1_AMS_CELL_VOLTAGES_FRAME_ID (0x21u)
#define CAN1_AMS_CELL_TEMPERATURES_FRAME_ID (0x22u)
#define CAN1_ECU_STATUS_FRAME_ID (0x48u)
#define CAN1_EBS_STATUS_FRAME_ID (0x511u)
#define CAN1_FB_PEDALS_FRAME_ID (0x10u)
#define CAN1_MCU_SET_CCU_COOLING_POINTS_FRAME_ID (0x5au)
#define CAN1_CCU_STATUS_1_FRAME_ID (0x59u)
#define CAN1_CCU_STATUS_2_FRAME_ID (0x58u)
#define CAN1_VEHICLE_STATUS_FRAME_ID (0x3e8u)
#define CAN1_FAULT_FRAME_ID (0xffu)
#define CAN1_STEERING_FRAME_ID (0x12u)
#define CAN1_DBU_STATUS_2_FRAME_ID (0x41u)
#define CAN1_DV_CONTROL_TARGET_FRAME_ID (0x18u)
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_FRAME_ID (0x3e9u)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_FRAME_ID (0x189u)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_INFO_FRAME_ID (0x188u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ACC_FRAME_ID (0x187u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ALT_FRAME_ID (0x186u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_FRAME_ID (0x185u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_INFO_FRAME_ID (0x184u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_COURSE_FRAME_ID (0x183u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_ACC_FRAME_ID (0x182u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_FRAME_ID (0x181u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_INFO_FRAME_ID (0x180u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_FRAME_ID (0x179u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_INFO_FRAME_ID (0x178u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ACC_FRAME_ID (0x177u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ALT_FRAME_ID (0x176u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_FRAME_ID (0x175u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_INFO_FRAME_ID (0x174u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_COURSE_FRAME_ID (0x173u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_ACC_FRAME_ID (0x172u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_FRAME_ID (0x171u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_INFO_FRAME_ID (0x170u)
#define CAN1_SBG_ECAN_MSG_ODO_VEL_FRAME_ID (0x161u)
#define CAN1_SBG_ECAN_MSG_ODO_INFO_FRAME_ID (0x160u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_BODY_FRAME_ID (0x139u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_FRAME_ID (0x138u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_FRAME_ID (0x137u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_FRAME_ID (0x136u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_FRAME_ID (0x134u)
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_FRAME_ID (0x133u)
#define CAN1_SBG_ECAN_MSG_EKF_EULER_FRAME_ID (0x132u)
#define CAN1_SBG_ECAN_MSG_EKF_QUAT_FRAME_ID (0x131u)
#define CAN1_SBG_ECAN_MSG_EKF_INFO_FRAME_ID (0x130u)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_ANGLE_FRAME_ID (0x124u)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_VEL_FRAME_ID (0x123u)
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_FRAME_ID (0x122u)
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_FRAME_ID (0x121u)
#define CAN1_SBG_ECAN_MSG_IMU_INFO_FRAME_ID (0x120u)
#define CAN1_SBG_ECAN_MSG_UTC_1_FRAME_ID (0x111u)
#define CAN1_SBG_ECAN_MSG_UTC_0_FRAME_ID (0x110u)
#define CAN1_FS_DATALOGGER_RESERVED_6_FRAME_ID (0x755u)
#define CAN1_FS_DATALOGGER_RESERVED_5_FRAME_ID (0x754u)
#define CAN1_FS_DATALOGGER_RESERVED_4_FRAME_ID (0x753u)
#define CAN1_FS_DATALOGGER_RESERVED_3_FRAME_ID (0x752u)
#define CAN1_FS_DATALOGGER_RESERVED_2_FRAME_ID (0x751u)
#define CAN1_FS_DATALOGGER_RESERVED_1_FRAME_ID (0x750u)
#define CAN1_FS_DATALOGGER_STATUS_FRAME_ID (0x430u)
#define CAN1_VESC_STATUS_2_FRAME_ID (0xe19u)
#define CAN1_VESC_STATUS_4_FRAME_ID (0x1019u)
#define CAN1_VESC_STATUS_5_FRAME_ID (0x1b19u)
#define CAN1_VESC_STATUS_6_FRAME_ID (0x3a19u)
#define CAN1_VESC_SET_DUTY_FRAME_ID (0x19u)
#define CAN1_VESC_STATUS_FRAME_ID (0x919u)
#define CAN1_AMS_S1_VOLTAGES_1_FRAME_ID (0x258u)
#define CAN1_AMS_S1_VOLTAGES_2_FRAME_ID (0x259u)
#define CAN1_AMS_S2_VOLTAGES_1_FRAME_ID (0x25au)
#define CAN1_AMS_S2_VOLTAGES_2_FRAME_ID (0x25bu)
#define CAN1_AMS_S3_VOLTAGES_1_FRAME_ID (0x25cu)
#define CAN1_AMS_S3_VOLTAGES_2_FRAME_ID (0x25du)
#define CAN1_AMS_S4_VOLTAGES_1_FRAME_ID (0x25eu)
#define CAN1_AMS_S4_VOLTAGES_2_FRAME_ID (0x25fu)
#define CAN1_AMS_S5_VOLTAGES_1_FRAME_ID (0x260u)
#define CAN1_AMS_S5_VOLTAGES_2_FRAME_ID (0x261u)
#define CAN1_AMS_S6_VOLTAGES_1_FRAME_ID (0x262u)
#define CAN1_AMS_S6_VOLTAGES_2_FRAME_ID (0x263u)
#define CAN1_AMS_S7_VOLTAGES_1_FRAME_ID (0x264u)
#define CAN1_AMS_S7_VOLTAGES_2_FRAME_ID (0x265u)
#define CAN1_AMS_S8_VOLTAGES_1_FRAME_ID (0x266u)
#define CAN1_AMS_S8_VOLTAGES_2_FRAME_ID (0x267u)
#define CAN1_AMS_S9_VOLTAGES_1_FRAME_ID (0x268u)
#define CAN1_AMS_S9_VOLTAGES_2_FRAME_ID (0x269u)
#define CAN1_AMS_S10_VOLTAGES_1_FRAME_ID (0x26au)
#define CAN1_AMS_S10_VOLTAGES_2_FRAME_ID (0x26bu)
#define CAN1_AMS_S11_VOLTAGES_1_FRAME_ID (0x26cu)
#define CAN1_AMS_S11_VOLTAGES_2_FRAME_ID (0x26du)
#define CAN1_AMS_S12_VOLTAGES_1_FRAME_ID (0x26eu)
#define CAN1_AMS_S12_VOLTAGES_2_FRAME_ID (0x26fu)
#define CAN1_IVT_IMPROVED_STATUS_FRAME_ID (0x1du)
#define CAN1_RES_RECIEVE_PDO_FRAME_ID (0x211u)
#define CAN1_RES_TRANSMIT_SDO_FRAME_ID (0x591u)
#define CAN1_RES_RECIEVE_SDO_FRAME_ID (0x611u)
#define CAN1_RES_TRANSMIT_LSS_FRAME_ID (0x7e4u)
#define CAN1_RES_RECIEVE_LSS_FRAME_ID (0x7e5u)
#define CAN1_AMS_PARAMETERS_SET_FRAME_ID (0x192u)
#define CAN1_IVT_FRAME_ID (0x25u)
#define CAN1_IVT_EXTRA_FRAME_ID (0x26u)
#define CAN1_VEHICLE_STATUS_WHEEL_VELOCITIES_FRAME_ID (0x3eau)
#define CAN1_DV_CONTROL_TARGET_TV_FRAME_ID (0x17u)
#define CAN1_VMU_GPIO_FRAME_ID (0x2bcu)
#define CAN1_RES_SYNC_FRAME_ID (0x80u)
#define CAN1_RES_EMERGENCY_FRAME_ID (0x91u)
#define CAN1_RES_TIMESTAMP_FRAME_ID (0x100u)
#define CAN1_DV_INFO_FRAME_ID (0x16u)
#define CAN1_VEHICLE_STATUS_MOTOR_TORQUES_FRAME_ID (0x3ebu)
#define CAN1_VEHICLE_STATUS_MOTOR_TEMP_FRAME_ID (0x3ecu)
#define CAN1_VEHICLE_STATUS_INVERTER_TEMP_FRAME_ID (0x3edu)
#define CAN1_VEHICLE_STATUS_PEDALS_FRAME_ID (0x3eeu)
#define CAN1_AMK1_SETPOINTS_1_FRAME_ID (0x438u)
#define CAN1_AMK2_SETPOINTS_1_FRAME_ID (0x439u)
#define CAN1_AMK3_SETPOINTS_1_FRAME_ID (0x43au)
#define CAN1_AMK4_SETPOINTS_1_FRAME_ID (0x43bu)
#define CAN1_SBG_ECAN_MSG_TRACK_SLIP_CURVATUR_FRAME_ID (0x220u)
#define CAN1_SLIP_SENSOR_FRAME_ID (0x19au)
#define CAN1_JON_SLIP_FRAME_ID (0x19bu)
#define CAN1_VEHICLE_STATUS_ACCUMULATOR_SOC_FRAME_ID (0x3efu)

/* Frame lengths in bytes. */
#define CAN1_AMS_STATUS_1_LENGTH (8u)
#define CAN1_AMS_STATE_LENGTH (8u)
#define CAN1_AMS_ERROR_LENGTH (8u)
#define CAN1_DV_DRIVING_DYNAMICS_1_LENGTH (8u)
#define CAN1_DV_DRIVING_DYNAMICS_2_LENGTH (6u)
#define CAN1_DV_SYSTEM_STATUS_LENGTH (5u)
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_LENGTH (8u)
#define CAN1_MCU_SET_DBU_INDICATOR_POINTS_LENGTH (1u)
#define CAN1_RES_STATUS_LENGTH (8u)
#define CAN1_RES_INITIALIZATION_LENGTH (8u)
#define CAN1_RES_NMT_NODE_CONTROL_LENGTH (8u)
#define CAN1_SWU_STATUS_LENGTH (8u)
#define CAN1_DBU_STATUS_1_LENGTH (8u)
#define CAN1_LV_POWER_SIGNAL_LENGTH (8u)
#define CAN1_LV_BMS_DATA_A_LENGTH (8u)
#define CAN1_LV_BMS_STATUS_A_LENGTH (8u)
#define CAN1_AMS_TEMPERATURES_LENGTH (6u)
#define CAN1_AMS_CELL_VOLTAGES_LENGTH (7u)
#define CAN1_AMS_CELL_TEMPERATURES_LENGTH (8u)
#define CAN1_ECU_STATUS_LENGTH (1u)
#define CAN1_EBS_STATUS_LENGTH (8u)
#define CAN1_FB_PEDALS_LENGTH (8u)
#define CAN1_MCU_SET_CCU_COOLING_POINTS_LENGTH (8u)
#define CAN1_CCU_STATUS_1_LENGTH (8u)
#define CAN1_CCU_STATUS_2_LENGTH (8u)
#define CAN1_VEHICLE_STATUS_LENGTH (8u)
#define CAN1_FAULT_LENGTH (8u)
#define CAN1_STEERING_LENGTH (8u)
#define CAN1_DBU_STATUS_2_LENGTH (8u)
#define CAN1_DV_CONTROL_TARGET_LENGTH (8u)
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_INFO_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ACC_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ALT_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_INFO_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_COURSE_LENGTH (4u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_ACC_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_INFO_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_INFO_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ACC_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ALT_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_INFO_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_COURSE_LENGTH (4u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_ACC_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_INFO_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_ODO_VEL_LENGTH (2u)
#define CAN1_SBG_ECAN_MSG_ODO_INFO_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_BODY_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_EULER_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_QUAT_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_EKF_INFO_LENGTH (4u)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_ANGLE_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_VEL_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_IMU_INFO_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_UTC_1_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_UTC_0_LENGTH (8u)
#define CAN1_FS_DATALOGGER_RESERVED_6_LENGTH (8u)
#define CAN1_FS_DATALOGGER_RESERVED_5_LENGTH (8u)
#define CAN1_FS_DATALOGGER_RESERVED_4_LENGTH (8u)
#define CAN1_FS_DATALOGGER_RESERVED_3_LENGTH (8u)
#define CAN1_FS_DATALOGGER_RESERVED_2_LENGTH (8u)
#define CAN1_FS_DATALOGGER_RESERVED_1_LENGTH (8u)
#define CAN1_FS_DATALOGGER_STATUS_LENGTH (6u)
#define CAN1_VESC_STATUS_2_LENGTH (8u)
#define CAN1_VESC_STATUS_4_LENGTH (8u)
#define CAN1_VESC_STATUS_5_LENGTH (8u)
#define CAN1_VESC_STATUS_6_LENGTH (8u)
#define CAN1_VESC_SET_DUTY_LENGTH (8u)
#define CAN1_VESC_STATUS_LENGTH (8u)
#define CAN1_AMS_S1_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S1_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S2_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S2_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S3_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S3_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S4_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S4_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S5_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S5_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S6_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S6_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S7_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S7_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S8_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S8_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S9_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S9_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S10_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S10_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S11_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S11_VOLTAGES_2_LENGTH (5u)
#define CAN1_AMS_S12_VOLTAGES_1_LENGTH (6u)
#define CAN1_AMS_S12_VOLTAGES_2_LENGTH (5u)
#define CAN1_IVT_IMPROVED_STATUS_LENGTH (8u)
#define CAN1_RES_RECIEVE_PDO_LENGTH (8u)
#define CAN1_RES_TRANSMIT_SDO_LENGTH (8u)
#define CAN1_RES_RECIEVE_SDO_LENGTH (8u)
#define CAN1_RES_TRANSMIT_LSS_LENGTH (8u)
#define CAN1_RES_RECIEVE_LSS_LENGTH (8u)
#define CAN1_AMS_PARAMETERS_SET_LENGTH (8u)
#define CAN1_IVT_LENGTH (8u)
#define CAN1_IVT_EXTRA_LENGTH (8u)
#define CAN1_VEHICLE_STATUS_WHEEL_VELOCITIES_LENGTH (8u)
#define CAN1_DV_CONTROL_TARGET_TV_LENGTH (8u)
#define CAN1_VMU_GPIO_LENGTH (8u)
#define CAN1_RES_SYNC_LENGTH (8u)
#define CAN1_RES_EMERGENCY_LENGTH (8u)
#define CAN1_RES_TIMESTAMP_LENGTH (8u)
#define CAN1_DV_INFO_LENGTH (8u)
#define CAN1_VEHICLE_STATUS_MOTOR_TORQUES_LENGTH (8u)
#define CAN1_VEHICLE_STATUS_MOTOR_TEMP_LENGTH (8u)
#define CAN1_VEHICLE_STATUS_INVERTER_TEMP_LENGTH (8u)
#define CAN1_VEHICLE_STATUS_PEDALS_LENGTH (2u)
#define CAN1_AMK1_SETPOINTS_1_LENGTH (8u)
#define CAN1_AMK2_SETPOINTS_1_LENGTH (8u)
#define CAN1_AMK3_SETPOINTS_1_LENGTH (8u)
#define CAN1_AMK4_SETPOINTS_1_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_TRACK_SLIP_CURVATUR_LENGTH (6u)
#define CAN1_SLIP_SENSOR_LENGTH (8u)
#define CAN1_JON_SLIP_LENGTH (8u)
#define CAN1_VEHICLE_STATUS_ACCUMULATOR_SOC_LENGTH (8u)

/* Extended or standard frame types. */
#define CAN1_AMS_STATUS_1_IS_EXTENDED (0)
#define CAN1_AMS_STATE_IS_EXTENDED (0)
#define CAN1_AMS_ERROR_IS_EXTENDED (0)
#define CAN1_DV_DRIVING_DYNAMICS_1_IS_EXTENDED (0)
#define CAN1_DV_DRIVING_DYNAMICS_2_IS_EXTENDED (0)
#define CAN1_DV_SYSTEM_STATUS_IS_EXTENDED (0)
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_IS_EXTENDED (0)
#define CAN1_MCU_SET_DBU_INDICATOR_POINTS_IS_EXTENDED (0)
#define CAN1_RES_STATUS_IS_EXTENDED (0)
#define CAN1_RES_INITIALIZATION_IS_EXTENDED (0)
#define CAN1_RES_NMT_NODE_CONTROL_IS_EXTENDED (0)
#define CAN1_SWU_STATUS_IS_EXTENDED (0)
#define CAN1_DBU_STATUS_1_IS_EXTENDED (0)
#define CAN1_LV_POWER_SIGNAL_IS_EXTENDED (0)
#define CAN1_LV_BMS_DATA_A_IS_EXTENDED (0)
#define CAN1_LV_BMS_STATUS_A_IS_EXTENDED (0)
#define CAN1_AMS_TEMPERATURES_IS_EXTENDED (0)
#define CAN1_AMS_CELL_VOLTAGES_IS_EXTENDED (0)
#define CAN1_AMS_CELL_TEMPERATURES_IS_EXTENDED (0)
#define CAN1_ECU_STATUS_IS_EXTENDED (0)
#define CAN1_EBS_STATUS_IS_EXTENDED (0)
#define CAN1_FB_PEDALS_IS_EXTENDED (0)
#define CAN1_MCU_SET_CCU_COOLING_POINTS_IS_EXTENDED (0)
#define CAN1_CCU_STATUS_1_IS_EXTENDED (0)
#define CAN1_CCU_STATUS_2_IS_EXTENDED (0)
#define CAN1_VEHICLE_STATUS_IS_EXTENDED (0)
#define CAN1_FAULT_IS_EXTENDED (0)
#define CAN1_STEERING_IS_EXTENDED (0)
#define CAN1_DBU_STATUS_2_IS_EXTENDED (0)
#define CAN1_DV_CONTROL_TARGET_IS_EXTENDED (0)
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ALT_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_POS_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_COURSE_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ALT_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_POS_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_COURSE_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_ODO_VEL_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_ODO_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_BODY_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_POS_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_EULER_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_QUAT_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_ANGLE_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_VEL_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_IMU_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_UTC_1_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_UTC_0_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_RESERVED_6_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_RESERVED_5_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_RESERVED_4_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_RESERVED_3_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_RESERVED_2_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_RESERVED_1_IS_EXTENDED (0)
#define CAN1_FS_DATALOGGER_STATUS_IS_EXTENDED (0)
#define CAN1_VESC_STATUS_2_IS_EXTENDED (1)
#define CAN1_VESC_STATUS_4_IS_EXTENDED (1)
#define CAN1_VESC_STATUS_5_IS_EXTENDED (1)
#define CAN1_VESC_STATUS_6_IS_EXTENDED (1)
#define CAN1_VESC_SET_DUTY_IS_EXTENDED (1)
#define CAN1_VESC_STATUS_IS_EXTENDED (1)
#define CAN1_AMS_S1_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S1_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S2_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S2_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S3_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S3_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S4_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S4_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S5_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S5_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S6_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S6_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S7_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S7_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S8_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S8_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S9_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S9_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S10_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S10_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S11_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S11_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_AMS_S12_VOLTAGES_1_IS_EXTENDED (0)
#define CAN1_AMS_S12_VOLTAGES_2_IS_EXTENDED (0)
#define CAN1_IVT_IMPROVED_STATUS_IS_EXTENDED (0)
#define CAN1_RES_RECIEVE_PDO_IS_EXTENDED (0)
#define CAN1_RES_TRANSMIT_SDO_IS_EXTENDED (0)
#define CAN1_RES_RECIEVE_SDO_IS_EXTENDED (0)
#define CAN1_RES_TRANSMIT_LSS_IS_EXTENDED (0)
#define CAN1_RES_RECIEVE_LSS_IS_EXTENDED (0)
#define CAN1_AMS_PARAMETERS_SET_IS_EXTENDED (0)
#define CAN1_IVT_IS_EXTENDED (0)
#define CAN1_IVT_EXTRA_IS_EXTENDED (0)
#define CAN1_VEHICLE_STATUS_WHEEL_VELOCITIES_IS_EXTENDED (0)
#define CAN1_DV_CONTROL_TARGET_TV_IS_EXTENDED (0)
#define CAN1_VMU_GPIO_IS_EXTENDED (0)
#define CAN1_RES_SYNC_IS_EXTENDED (0)
#define CAN1_RES_EMERGENCY_IS_EXTENDED (0)
#define CAN1_RES_TIMESTAMP_IS_EXTENDED (0)
#define CAN1_DV_INFO_IS_EXTENDED (0)
#define CAN1_VEHICLE_STATUS_MOTOR_TORQUES_IS_EXTENDED (0)
#define CAN1_VEHICLE_STATUS_MOTOR_TEMP_IS_EXTENDED (0)
#define CAN1_VEHICLE_STATUS_INVERTER_TEMP_IS_EXTENDED (0)
#define CAN1_VEHICLE_STATUS_PEDALS_IS_EXTENDED (0)
#define CAN1_AMK1_SETPOINTS_1_IS_EXTENDED (0)
#define CAN1_AMK2_SETPOINTS_1_IS_EXTENDED (0)
#define CAN1_AMK3_SETPOINTS_1_IS_EXTENDED (0)
#define CAN1_AMK4_SETPOINTS_1_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_TRACK_SLIP_CURVATUR_IS_EXTENDED (0)
#define CAN1_SLIP_SENSOR_IS_EXTENDED (0)
#define CAN1_JON_SLIP_IS_EXTENDED (0)
#define CAN1_VEHICLE_STATUS_ACCUMULATOR_SOC_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define CAN1_AMS_STATUS_1_CYCLE_TIME_MS (400u)
#define CAN1_DV_DRIVING_DYNAMICS_1_CYCLE_TIME_MS (100u)
#define CAN1_DV_DRIVING_DYNAMICS_2_CYCLE_TIME_MS (100u)
#define CAN1_DV_SYSTEM_STATUS_CYCLE_TIME_MS (100u)
#define CAN1_AMS_TEMPERATURES_CYCLE_TIME_MS (1200u)
#define CAN1_AMS_CELL_VOLTAGES_CYCLE_TIME_MS (800u)
#define CAN1_AMS_CELL_TEMPERATURES_CYCLE_TIME_MS (1200u)
#define CAN1_EBS_STATUS_CYCLE_TIME_MS (100u)
#define CAN1_CCU_STATUS_1_CYCLE_TIME_MS (10u)

/* Signal choices. */
#define CAN1_AMS_STATUS_1_CHARGING_STATUS_IDLE_CHOICE (0u)
#define CAN1_AMS_STATUS_1_CHARGING_STATUS_CHARGING_CHOICE (1u)
#define CAN1_AMS_STATUS_1_CHARGING_STATUS_DISCHARGING_CHOICE (2u)
#define CAN1_AMS_STATUS_1_CHARGING_STATUS_FULL_CHOICE (3u)

#define CAN1_AMS_STATUS_1_AIR1_CLOSED_OPEN_CHOICE (0u)
#define CAN1_AMS_STATUS_1_AIR1_CLOSED_CLOSED_CHOICE (1u)

#define CAN1_AMS_STATUS_1_AIR2_CLOSED_OPEN_CHOICE (0u)
#define CAN1_AMS_STATUS_1_AIR2_CLOSED_CLOSED_CHOICE (1u)

#define CAN1_AMS_STATUS_1_SC_CLOSED_OPEN_CHOICE (0u)
#define CAN1_AMS_STATUS_1_SC_CLOSED_CLOSED_CHOICE (1u)

#define CAN1_AMS_STATUS_1_PRE_CHARGE_STATUS_NOT_ACTIVE_CHOICE (0u)
#define CAN1_AMS_STATUS_1_PRE_CHARGE_STATUS_ACTIVE_CHOICE (1u)

#define CAN1_AMS_STATUS_1_AMS_ERROR_OK_CHOICE (0u)
#define CAN1_AMS_STATUS_1_AMS_ERROR_ERROR_CHOICE (1u)

#define CAN1_AMS_STATUS_1_IMD_ERROR_OK_CHOICE (0u)
#define CAN1_AMS_STATUS_1_IMD_ERROR_ERROR_CHOICE (1u)

#define CAN1_AMS_STATUS_1_BALANCE_STATUS_INACTIVE_CHOICE (0u)
#define CAN1_AMS_STATUS_1_BALANCE_STATUS_ACTIVE_CHOICE (1u)

#define CAN1_AMS_STATE_STATE_AMS_BALANCE__CHOICE (0u)
#define CAN1_AMS_STATE_STATE_AMS_BALANCE_IDLE_CHOICE (1u)
#define CAN1_AMS_STATE_STATE_AMS_CHARGE__CHOICE (2u)
#define CAN1_AMS_STATE_STATE_AMS_CHARGE_CHARGE_CHOICE (3u)
#define CAN1_AMS_STATE_STATE_AMS_CHARGE_EXIT_CHOICE (4u)
#define CAN1_AMS_STATE_STATE_AMS_CHARGE_FAILED_CHOICE (5u)
#define CAN1_AMS_STATE_STATE_AMS_CHARGE_PRECHARGE_CHOICE (6u)
#define CAN1_AMS_STATE_STATE_AMS_CHARGE_START_CHARGER_CHOICE (7u)
#define CAN1_AMS_STATE_STATE_AMS_DRIVE__CHOICE (8u)
#define CAN1_AMS_STATE_STATE_AMS_DRIVE_DRIVE_CHOICE (9u)
#define CAN1_AMS_STATE_STATE_AMS_DRIVE_EXIT_CHOICE (10u)
#define CAN1_AMS_STATE_STATE_AMS_DRIVE_PRECHARGE_CHOICE (11u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN__CHOICE (12u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_INIT_ADC_CHOICE (13u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_INIT_COOL_CHOICE (14u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_INIT_IVT_CHOICE (15u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_INIT_LTC_CHOICE (16u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_INIT_STATE_MACHINE_CHOICE (17u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_SAFE_STATE_CHOICE (18u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_SETUP_COMPLETE_CHOICE (19u)
#define CAN1_AMS_STATE_STATE_AMS_MAIN_WATCHDOG_CHOICE (20u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE__CHOICE (21u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_CLOSE_AIR_MINUS_CHOICE (22u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_CLOSE_AIR_PLUS_CHOICE (23u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_CLOSE_PRECHARGE_CHOICE (24u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_DONE_CHOICE (25u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_FAILED1_CHOICE (26u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_FAILED2_CHOICE (27u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_FAILED3_CHOICE (28u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_FAILED4_CHOICE (29u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_FAILED5_CHOICE (30u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_OPEN_PRECHARGE_CHOICE (31u)
#define CAN1_AMS_STATE_STATE_AMS_PRECHARGE_PRECHARGE_CHOICE (32u)
#define CAN1_AMS_STATE_STATE_AMS_STATE_MACHINE__CHOICE (33u)
#define CAN1_AMS_STATE_STATE_AMS_STATE_MACHINE_BALANCE_CHOICE (34u)
#define CAN1_AMS_STATE_STATE_AMS_STATE_MACHINE_CHARGE_CHOICE (35u)
#define CAN1_AMS_STATE_STATE_AMS_STATE_MACHINE_DRIVE_CHOICE (36u)
#define CAN1_AMS_STATE_STATE_AMS_STATE_MACHINE_IDLE_CHOICE (37u)

#define CAN1_AMS_ERROR_ERROR_UNKNOWN_ERROR_CHOICE (0u)
#define CAN1_AMS_ERROR_ERROR_PROGRAM_EXIT_CHOICE (1u)
#define CAN1_AMS_ERROR_ERROR_IMD_ERROR_CHOICE (2u)
#define CAN1_AMS_ERROR_ERROR_AMS_ERROR_CHOICE (3u)
#define CAN1_AMS_ERROR_ERROR_AIR_PLUS_RELAY_FAILED_CHOICE (4u)
#define CAN1_AMS_ERROR_ERROR_AIR_MINUS_RELAY_FAILED_CHOICE (5u)
#define CAN1_AMS_ERROR_ERROR_PRECHARGE_RELAY_FAILED_CHOICE (6u)
#define CAN1_AMS_ERROR_ERROR_PRECHARGE_TIMEOUT_CHOICE (7u)
#define CAN1_AMS_ERROR_ERROR_NO_CHARGER_CHOICE (8u)
#define CAN1_AMS_ERROR_ERROR_NO_NEW_ACCUMULATOR_VOLTAGE_CHOICE (9u)
#define CAN1_AMS_ERROR_ERROR_NO_NEW_ACCUMULATOR_CURRENT_CHOICE (10u)
#define CAN1_AMS_ERROR_ERROR_NO_NEW_INVERTER_VOLTAGE_CHOICE (11u)
#define CAN1_AMS_ERROR_ERROR_CELL_OVER_VOLTAGE_CHOICE (12u)
#define CAN1_AMS_ERROR_ERROR_CELL_UNDER_VOLTAGE_CHOICE (13u)
#define CAN1_AMS_ERROR_ERROR_CELL_OVER_TEMPERATURE_CHOICE (14u)
#define CAN1_AMS_ERROR_ERROR_CELL_UNDER_TEMPERATURE_CHOICE (15u)
#define CAN1_AMS_ERROR_ERROR_ACCUMULATOR_OVER_VOLTAGE_CHOICE (16u)
#define CAN1_AMS_ERROR_ERROR_ACCUMULATOR_UNDER_VOLTAGE_CHOICE (17u)
#define CAN1_AMS_ERROR_ERROR_ACCUMULATOR_OVER_CURRENT_CHOICE (18u)
#define CAN1_AMS_ERROR_ERROR_ACCUMULATOR_UNDER_CURRENT_CHOICE (19u)

#define CAN1_DV_SYSTEM_STATUS_AS_STATE_OFF_CHOICE (1u)
#define CAN1_DV_SYSTEM_STATUS_AS_STATE_READY_CHOICE (2u)
#define CAN1_DV_SYSTEM_STATUS_AS_STATE_DRIVING_CHOICE (3u)
#define CAN1_DV_SYSTEM_STATUS_AS_STATE_EMERGENCY_BRAKE_CHOICE (4u)
#define CAN1_DV_SYSTEM_STATUS_AS_STATE_FINISH_CHOICE (5u)

#define CAN1_DV_SYSTEM_STATUS_EBS_STATE_UNAVAILABLE_CHOICE (1u)
#define CAN1_DV_SYSTEM_STATUS_EBS_STATE_ARMED_CHOICE (2u)
#define CAN1_DV_SYSTEM_STATUS_EBS_STATE_ACTIVATED_CHOICE (3u)

#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_ACCELERATION_CHOICE (1u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_SKIDPAD_CHOICE (2u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_TRACKDRIVE_CHOICE (3u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_BRAKETEST_CHOICE (4u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_INSPECTION_CHOICE (5u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_AUTOCROSS_CHOICE (6u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_MANUAL_DRIVING_CHOICE (7u)

#define CAN1_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_DISENGAGED_CHOICE (1u)
#define CAN1_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_ENGAGED_CHOICE (2u)
#define CAN1_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_AVAILABLE_CHOICE (3u)

#define CAN1_RES_STATUS_E_STOP_E_STOP_OK_CHOICE (0u)
#define CAN1_RES_STATUS_E_STOP_E_STOP_ACTIVE_CHOICE (1u)

#define CAN1_RES_STATUS_SWITCH_STATUS_LOW_CHOICE (0u)
#define CAN1_RES_STATUS_SWITCH_STATUS_HIGH_CHOICE (1u)

#define CAN1_RES_STATUS_BUTTON_STATUS_LOW_CHOICE (0u)
#define CAN1_RES_STATUS_BUTTON_STATUS_HIGH_CHOICE (1u)

#define CAN1_RES_STATUS_E_STOP_REDUNDANCY_E_STOP_OK_CHOICE (0u)
#define CAN1_RES_STATUS_E_STOP_REDUNDANCY_E_STOP_ACTIVE_CHOICE (1u)

#define CAN1_DBU_STATUS_1_SELECTED_MISSION_NO_MISSION_SELECTED_CHOICE (0u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_AS_ACCELERATION_SELECTED_CHOICE (1u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_AS_SKIDPAD_SELECTED_CHOICE (2u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_AS_TRACKDRIVE_SELECTED_CHOICE (3u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_AS_BRAKETEST_SELECTED_CHOICE (4u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_AS_INSPECTION_SELECTED_CHOICE (5u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_AS_AUTOCROSS_SELECTED_CHOICE (6u)
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_MANUAL_DRIVING_SELECTED_CHOICE (7u)

#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_NO_ERROR_CHOICE (0u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_CELL_OVER_VOLTAGE_CHOICE (1u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_CELL_UNDER_VOLTAGE_CHOICE (2u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_OVER_TEMPERATURE_CHOICE (3u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_UNDER_TEMPERATURE_CHOICE (4u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_OVER_CURRENT_CHOICE (5u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_UNDER_CURRENT_CHOICE (6u)
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_ADC_TIMEOUT_CHOICE (7u)

#define CAN1_ECU_STATUS_TS_NOT_OFF_TS_OFF_CHOICE (0u)
#define CAN1_ECU_STATUS_TS_NOT_OFF_TS_ON_CHOICE (1u)

#define CAN1_ECU_STATUS_RST_BUTTON_RELEASED_CHOICE (0u)
#define CAN1_ECU_STATUS_RST_BUTTON_PUSHED_CHOICE (1u)

#define CAN1_ECU_STATUS_SIDEPANEL_ACTIVATE_TS_BUTTON_RELEASED_CHOICE (0u)
#define CAN1_ECU_STATUS_SIDEPANEL_ACTIVATE_TS_BUTTON_PUSHED_CHOICE (1u)

#define CAN1_ECU_STATUS_TS_OFF_TS_ON_CHOICE (0u)
#define CAN1_ECU_STATUS_TS_OFF_TS_OFF_CHOICE (1u)

#define CAN1_EBS_STATUS_EBS_STATUS_EBS_UNAVAILABLE_CHOICE (1u)
#define CAN1_EBS_STATUS_EBS_STATUS_EBS_ARMED_CHOICE (2u)
#define CAN1_EBS_STATUS_EBS_STATUS_EBS_ACTIVATED_CHOICE (3u)

#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_INIT_CHOICE (0u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_WAIT_MISSION_CHOICE (1u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_WAIT_TANK_CHOICE (2u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_WAIT_RELEASE_CHOICE (3u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_TEST_PRIMARY_CHOICE (4u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_TEST_SECONDARY_CHOICE (5u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_UNAVAILABLE_CHOICE (6u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_ARMED_CHOICE (7u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_FINISHED_CHOICE (8u)
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_EBS_FAULT_CHOICE (9u)

#define CAN1_EBS_STATUS_EBS_ERROR_NO_ERROR_CHOICE (0u)
#define CAN1_EBS_STATUS_EBS_ERROR_TIMEOUT_ERROR_CHOICE (1u)
#define CAN1_EBS_STATUS_EBS_ERROR_AS_EMERGENCY_ERROR_CHOICE (2u)
#define CAN1_EBS_STATUS_EBS_ERROR_LOW_TANK_PRESSURE_CHOICE (3u)
#define CAN1_EBS_STATUS_EBS_ERROR_BRAKE_TOOK_TO_LONG_CHOICE (4u)
#define CAN1_EBS_STATUS_EBS_ERROR_SDC_OPEN_UNEXPECTEDLY_CHOICE (5u)
#define CAN1_EBS_STATUS_EBS_ERROR_GENERAL_FAULT_CHOICE (6u)
#define CAN1_EBS_STATUS_EBS_ERROR_WATCHDOG_FAULT_CHOICE (7u)
#define CAN1_EBS_STATUS_EBS_ERROR_MISSION_CHANGED_DURING_OPERATION_CHOICE (8u)
#define CAN1_EBS_STATUS_EBS_ERROR_AS_SYSTEM_NOT_OK_CHOICE (9u)
#define CAN1_EBS_STATUS_EBS_ERROR_RES_NOT_OK_CHOICE (10u)
#define CAN1_EBS_STATUS_EBS_ERROR_VESC_NOT_OK_CHOICE (11u)
#define CAN1_EBS_STATUS_EBS_ERROR_DSPACE_NOT_OK_CHOICE (12u)
#define CAN1_EBS_STATUS_EBS_ERROR_SENSOR_NOT_OK_CHOICE (13u)
#define CAN1_EBS_STATUS_EBS_ERROR_BRAKE_UNEXPECTEDLY_CHOICE (14u)

#define CAN1_EBS_STATUS_SDC_STATUS_NOMESSAGE_CHOICE (0u)
#define CAN1_EBS_STATUS_SDC_STATUS_OPEN_CHOICE (2u)
#define CAN1_EBS_STATUS_SDC_STATUS_TO_FRONTBOX_CHOICE (3u)
#define CAN1_EBS_STATUS_SDC_STATUS_CLOSED_CHOICE (4u)

#define CAN1_FB_PEDALS_BPPS_ERROR_OK_CHOICE (0u)
#define CAN1_FB_PEDALS_BPPS_ERROR_FAULT_CHOICE (1u)

#define CAN1_FB_PEDALS_APPS_ERROR_OK_CHOICE (0u)
#define CAN1_FB_PEDALS_APPS_ERROR_FAULT_CHOICE (1u)

#define CAN1_VEHICLE_STATUS_CAR_STATE_CAR_OFF_CHOICE (0u)

#define CAN1_VEHICLE_STATUS_READY_TO_DRIVE_NOT_R2_D_CHOICE (0u)
#define CAN1_VEHICLE_STATUS_READY_TO_DRIVE_R2_D_CHOICE (1u)

#define CAN1_VEHICLE_STATUS_TORQUE_VECTORING_ACTIVE_OFF_CHOICE (0u)
#define CAN1_VEHICLE_STATUS_TORQUE_VECTORING_ACTIVE_ON_CHOICE (1u)

#define CAN1_VEHICLE_STATUS_TRACTION_CONTROL_ON_OFF_CHOICE (0u)
#define CAN1_VEHICLE_STATUS_TRACTION_CONTROL_ON_ON_CHOICE (1u)

#define CAN1_VEHICLE_STATUS_ABS_ON_OFF_CHOICE (0u)
#define CAN1_VEHICLE_STATUS_ABS_ON_ON_CHOICE (1u)

#define CAN1_STEERING_STEERING_ANGLE_ERROR_OK_CHOICE (0u)
#define CAN1_STEERING_STEERING_ANGLE_ERROR_FAULT_CHOICE (1u)

#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_EMERGENCY_CHOICE (0u)
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_ACCELERATION_CHOICE (1u)
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_SKIDPAD_CHOICE (2u)
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_TRACKDRIVE_CHOICE (3u)
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_BRAKETEST_CHOICE (4u)
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_INSPECTION_CHOICE (5u)
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_AUTOCROSS_CHOICE (6u)
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_MISSION__FINISHED_CHOICE (7u)

#define CAN1_AMS_PARAMETERS_SET_START_BALANCING_DISABLE_CHOICE (0u)
#define CAN1_AMS_PARAMETERS_SET_START_BALANCING_ENABLE_CHOICE (1u)

#define CAN1_DV_CONTROL_TARGET_TV_DV_MISSION_STATUS_TV_EMERGENCY_CHOICE (0u)
#define CAN1_DV_CONTROL_TARGET_TV_DV_MISSION_STATUS_TV_ACCELERATION_CHOICE (1u)
#define CAN1_DV_CONTROL_TARGET_TV_DV_MISSION_STATUS_TV_SKIDPAD_CHOICE (2u)
#define CAN1_DV_CONTROL_TARGET_TV_DV_MISSION_STATUS_TV_TRACKDRIVE_CHOICE (3u)
#define CAN1_DV_CONTROL_TARGET_TV_DV_MISSION_STATUS_TV_BRAKETEST_CHOICE (4u)
#define CAN1_DV_CONTROL_TARGET_TV_DV_MISSION_STATUS_TV_INSPECTION_CHOICE (5u)
#define CAN1_DV_CONTROL_TARGET_TV_DV_MISSION_STATUS_TV_AUTOCROSS_CHOICE (6u)
#define CAN1_DV_CONTROL_TARGET_TV_DV_MISSION_STATUS_TV_MISSION__FINISHED_CHOICE (7u)

#define CAN1_VMU_GPIO_MSGS_TYPE_STATUS_CHOICE (0u)
#define CAN1_VMU_GPIO_MSGS_TYPE_SET_OUTPUT_CHOICE (1u)
#define CAN1_VMU_GPIO_MSGS_TYPE_CONFIG_GPIO_CHOICE (2u)

/* Frame Names. */
#define CAN1_AMS_STATUS_1_NAME "ams_status_1"
#define CAN1_AMS_STATE_NAME "ams_state"
#define CAN1_AMS_ERROR_NAME "ams_error"
#define CAN1_DV_DRIVING_DYNAMICS_1_NAME "dv_driving_dynamics_1"
#define CAN1_DV_DRIVING_DYNAMICS_2_NAME "dv_driving_dynamics_2"
#define CAN1_DV_SYSTEM_STATUS_NAME "dv_system_status"
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_NAME "mcu_set_ecu_indicator_points"
#define CAN1_MCU_SET_DBU_INDICATOR_POINTS_NAME "mcu_set_dbu_indicator_points"
#define CAN1_RES_STATUS_NAME "res_status"
#define CAN1_RES_INITIALIZATION_NAME "res_initialization"
#define CAN1_RES_NMT_NODE_CONTROL_NAME "res_nmt_node_control"
#define CAN1_SWU_STATUS_NAME "swu_status"
#define CAN1_DBU_STATUS_1_NAME "dbu_status_1"
#define CAN1_LV_POWER_SIGNAL_NAME "lv_power_signal"
#define CAN1_LV_BMS_DATA_A_NAME "lv_bms_data_a"
#define CAN1_LV_BMS_STATUS_A_NAME "lv_bms_status_a"
#define CAN1_AMS_TEMPERATURES_NAME "ams_temperatures"
#define CAN1_AMS_CELL_VOLTAGES_NAME "ams_cell_voltages"
#define CAN1_AMS_CELL_TEMPERATURES_NAME "ams_cell_temperatures"
#define CAN1_ECU_STATUS_NAME "ecu_status"
#define CAN1_EBS_STATUS_NAME "ebs_status"
#define CAN1_FB_PEDALS_NAME "fb_pedals"
#define CAN1_MCU_SET_CCU_COOLING_POINTS_NAME "mcu_set_ccu_cooling_points"
#define CAN1_CCU_STATUS_1_NAME "ccu_status_1"
#define CAN1_CCU_STATUS_2_NAME "ccu_status_2"
#define CAN1_VEHICLE_STATUS_NAME "vehicle_status"
#define CAN1_FAULT_NAME "fault"
#define CAN1_STEERING_NAME "steering"
#define CAN1_DBU_STATUS_2_NAME "dbu_status_2"
#define CAN1_DV_CONTROL_TARGET_NAME "dv_control_target"
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_NAME "vehicle_status_wheel_speed"
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_NAME "SBG_ECAN_MSG_GPS2_HDT"
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_INFO_NAME "SBG_ECAN_MSG_GPS2_HDT_INFO"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ACC_NAME "SBG_ECAN_MSG_GPS2_POS_ACC"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ALT_NAME "SBG_ECAN_MSG_GPS2_POS_ALT"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_NAME "SBG_ECAN_MSG_GPS2_POS"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_INFO_NAME "SBG_ECAN_MSG_GPS2_POS_INFO"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_COURSE_NAME "SBG_ECAN_MSG_GPS2_VEL_COURSE"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_ACC_NAME "SBG_ECAN_MSG_GPS2_VEL_ACC"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_NAME "SBG_ECAN_MSG_GPS2_VEL"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_INFO_NAME "SBG_ECAN_MSG_GPS2_VEL_INFO"
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_NAME "SBG_ECAN_MSG_GPS1_HDT"
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_INFO_NAME "SBG_ECAN_MSG_GPS1_HDT_INFO"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ACC_NAME "SBG_ECAN_MSG_GPS1_POS_ACC"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ALT_NAME "SBG_ECAN_MSG_GPS1_POS_ALT"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_NAME "SBG_ECAN_MSG_GPS1_POS"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_INFO_NAME "SBG_ECAN_MSG_GPS1_POS_INFO"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_COURSE_NAME "SBG_ECAN_MSG_GPS1_VEL_COURSE"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_ACC_NAME "SBG_ECAN_MSG_GPS1_VEL_ACC"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_NAME "SBG_ECAN_MSG_GPS1_VEL"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_INFO_NAME "SBG_ECAN_MSG_GPS1_VEL_INFO"
#define CAN1_SBG_ECAN_MSG_ODO_VEL_NAME "SBG_ECAN_MSG_ODO_VEL"
#define CAN1_SBG_ECAN_MSG_ODO_INFO_NAME "SBG_ECAN_MSG_ODO_INFO"
#define CAN1_SBG_ECAN_MSG_EKF_VEL_BODY_NAME "SBG_ECAN_MSG_EKF_VEL_BODY"
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_NAME "SBG_ECAN_MSG_EKF_VEL_NED_ACC"
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_NAME "SBG_ECAN_MSG_EKF_VEL_NED"
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_NAME "SBG_ECAN_MSG_EKF_POS_ACC"
#define CAN1_SBG_ECAN_MSG_EKF_POS_NAME "SBG_ECAN_MSG_EKF_POS"
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_NAME "SBG_ECAN_MSG_EKF_ORIENTATION_ACC"
#define CAN1_SBG_ECAN_MSG_EKF_EULER_NAME "SBG_ECAN_MSG_EKF_EULER"
#define CAN1_SBG_ECAN_MSG_EKF_QUAT_NAME "SBG_ECAN_MSG_EKF_QUAT"
#define CAN1_SBG_ECAN_MSG_EKF_INFO_NAME "SBG_ECAN_MSG_EKF_INFO"
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_ANGLE_NAME "SBG_ECAN_MSG_IMU_DELTA_ANGLE"
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_VEL_NAME "SBG_ECAN_MSG_IMU_DELTA_VEL"
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_NAME "SBG_ECAN_MSG_IMU_GYRO"
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_NAME "SBG_ECAN_MSG_IMU_ACCEL"
#define CAN1_SBG_ECAN_MSG_IMU_INFO_NAME "SBG_ECAN_MSG_IMU_INFO"
#define CAN1_SBG_ECAN_MSG_UTC_1_NAME "SBG_ECAN_MSG_UTC_1"
#define CAN1_SBG_ECAN_MSG_UTC_0_NAME "SBG_ECAN_MSG_UTC_0"
#define CAN1_FS_DATALOGGER_RESERVED_6_NAME "FS_Datalogger_Reserved_6"
#define CAN1_FS_DATALOGGER_RESERVED_5_NAME "FS_Datalogger_Reserved_5"
#define CAN1_FS_DATALOGGER_RESERVED_4_NAME "FS_Datalogger_Reserved_4"
#define CAN1_FS_DATALOGGER_RESERVED_3_NAME "FS_Datalogger_Reserved_3"
#define CAN1_FS_DATALOGGER_RESERVED_2_NAME "FS_Datalogger_Reserved_2"
#define CAN1_FS_DATALOGGER_RESERVED_1_NAME "FS_Datalogger_Reserved_1"
#define CAN1_FS_DATALOGGER_STATUS_NAME "FS_Datalogger_Status"
#define CAN1_VESC_STATUS_2_NAME "vesc_status_2"
#define CAN1_VESC_STATUS_4_NAME "vesc_status_4"
#define CAN1_VESC_STATUS_5_NAME "vesc_status_5"
#define CAN1_VESC_STATUS_6_NAME "vesc_status_6"
#define CAN1_VESC_SET_DUTY_NAME "vesc_set_duty"
#define CAN1_VESC_STATUS_NAME "vesc_status"
#define CAN1_AMS_S1_VOLTAGES_1_NAME "ams_s1_voltages_1"
#define CAN1_AMS_S1_VOLTAGES_2_NAME "ams_s1_voltages_2"
#define CAN1_AMS_S2_VOLTAGES_1_NAME "ams_s2_voltages_1"
#define CAN1_AMS_S2_VOLTAGES_2_NAME "ams_s2_voltages_2"
#define CAN1_AMS_S3_VOLTAGES_1_NAME "ams_s3_voltages_1"
#define CAN1_AMS_S3_VOLTAGES_2_NAME "ams_s3_voltages_2"
#define CAN1_AMS_S4_VOLTAGES_1_NAME "ams_s4_voltages_1"
#define CAN1_AMS_S4_VOLTAGES_2_NAME "ams_s4_voltages_2"
#define CAN1_AMS_S5_VOLTAGES_1_NAME "ams_s5_voltages_1"
#define CAN1_AMS_S5_VOLTAGES_2_NAME "ams_s5_voltages_2"
#define CAN1_AMS_S6_VOLTAGES_1_NAME "ams_s6_voltages_1"
#define CAN1_AMS_S6_VOLTAGES_2_NAME "ams_s6_voltages_2"
#define CAN1_AMS_S7_VOLTAGES_1_NAME "ams_s7_voltages_1"
#define CAN1_AMS_S7_VOLTAGES_2_NAME "ams_s7_voltages_2"
#define CAN1_AMS_S8_VOLTAGES_1_NAME "ams_s8_voltages_1"
#define CAN1_AMS_S8_VOLTAGES_2_NAME "ams_s8_voltages_2"
#define CAN1_AMS_S9_VOLTAGES_1_NAME "ams_s9_voltages_1"
#define CAN1_AMS_S9_VOLTAGES_2_NAME "ams_s9_voltages_2"
#define CAN1_AMS_S10_VOLTAGES_1_NAME "ams_s10_voltages_1"
#define CAN1_AMS_S10_VOLTAGES_2_NAME "ams_s10_voltages_2"
#define CAN1_AMS_S11_VOLTAGES_1_NAME "ams_s11_voltages_1"
#define CAN1_AMS_S11_VOLTAGES_2_NAME "ams_s11_voltages_2"
#define CAN1_AMS_S12_VOLTAGES_1_NAME "ams_s12_voltages_1"
#define CAN1_AMS_S12_VOLTAGES_2_NAME "ams_s12_voltages_2"
#define CAN1_IVT_IMPROVED_STATUS_NAME "ivt_improved_status"
#define CAN1_RES_RECIEVE_PDO_NAME "res_recieve_PDO"
#define CAN1_RES_TRANSMIT_SDO_NAME "res_transmit_SDO"
#define CAN1_RES_RECIEVE_SDO_NAME "res_recieve_SDO"
#define CAN1_RES_TRANSMIT_LSS_NAME "res_transmit_LSS"
#define CAN1_RES_RECIEVE_LSS_NAME "res_recieve_LSS"
#define CAN1_AMS_PARAMETERS_SET_NAME "AMS_parameters_set"
#define CAN1_IVT_NAME "IVT"
#define CAN1_IVT_EXTRA_NAME "IVT_extra"
#define CAN1_VEHICLE_STATUS_WHEEL_VELOCITIES_NAME "vehicle_status_wheel_velocities"
#define CAN1_DV_CONTROL_TARGET_TV_NAME "dv_control_target_TV"
#define CAN1_VMU_GPIO_NAME "vmu_gpio"
#define CAN1_RES_SYNC_NAME "res_sync"
#define CAN1_RES_EMERGENCY_NAME "res_emergency"
#define CAN1_RES_TIMESTAMP_NAME "res_timestamp"
#define CAN1_DV_INFO_NAME "dv_info"
#define CAN1_VEHICLE_STATUS_MOTOR_TORQUES_NAME "vehicle_status_motor_torques"
#define CAN1_VEHICLE_STATUS_MOTOR_TEMP_NAME "vehicle_status_motor_temp"
#define CAN1_VEHICLE_STATUS_INVERTER_TEMP_NAME "vehicle_status_inverter_temp"
#define CAN1_VEHICLE_STATUS_PEDALS_NAME "vehicle_status_pedals"
#define CAN1_AMK1_SETPOINTS_1_NAME "amk1_setpoints_1"
#define CAN1_AMK2_SETPOINTS_1_NAME "amk2_setpoints_1"
#define CAN1_AMK3_SETPOINTS_1_NAME "amk3_setpoints_1"
#define CAN1_AMK4_SETPOINTS_1_NAME "amk4_setpoints_1"
#define CAN1_SBG_ECAN_MSG_TRACK_SLIP_CURVATUR_NAME "SBG_ECAN_MSG_TRACK_SLIP_CURVATUR"
#define CAN1_SLIP_SENSOR_NAME "Slip_sensor"
#define CAN1_JON_SLIP_NAME "jon_slip"
#define CAN1_VEHICLE_STATUS_ACCUMULATOR_SOC_NAME "vehicle_status_accumulator_soc"

/* Signal Names. */
#define CAN1_AMS_STATUS_1_CHARGING_STATUS_NAME "charging_status"
#define CAN1_AMS_STATUS_1_AIR1_CLOSED_NAME "air1_closed"
#define CAN1_AMS_STATUS_1_AIR2_CLOSED_NAME "air2_closed"
#define CAN1_AMS_STATUS_1_SC_CLOSED_NAME "sc_closed"
#define CAN1_AMS_STATUS_1_PRE_CHARGE_STATUS_NAME "pre_charge_status"
#define CAN1_AMS_STATUS_1_AMS_ERROR_NAME "ams_error"
#define CAN1_AMS_STATUS_1_IMD_ERROR_NAME "imd_error"
#define CAN1_AMS_STATUS_1_STATE_OF_CHARGE_NAME "state_of_charge"
#define CAN1_AMS_STATUS_1_MIN_CELL_VOLTAGE_NAME "min_cell_voltage"
#define CAN1_AMS_STATUS_1_MAX_CELL_VOLTAGE_NAME "max_cell_voltage"
#define CAN1_AMS_STATUS_1_MIN_CELL_TEMPERATURE_NAME "min_cell_temperature"
#define CAN1_AMS_STATUS_1_MAX_CELL_TEMPERATURE_NAME "max_cell_temperature"
#define CAN1_AMS_STATUS_1_FAN_SPEED_NAME "fan_speed"
#define CAN1_AMS_STATUS_1_BALANCE_STATUS_NAME "balance_status"
#define CAN1_AMS_STATE_STATE_NAME "state"
#define CAN1_AMS_ERROR_ERROR_NAME "error"
#define CAN1_AMS_ERROR_RESET_CAUSE_NAME "reset_cause"
#define CAN1_DV_DRIVING_DYNAMICS_1_SPEED_ACTUAL_NAME "speed_actual"
#define CAN1_DV_DRIVING_DYNAMICS_1_SPEED_TARGET_NAME "speed_target"
#define CAN1_DV_DRIVING_DYNAMICS_1_STEERING_ANGLE_ACTUAL_NAME "steering_angle_actual"
#define CAN1_DV_DRIVING_DYNAMICS_1_STEERING_ANGLE_TARGET_NAME "steering_angle_target"
#define CAN1_DV_DRIVING_DYNAMICS_1_BRAKE_HYDR_ACTUAL_NAME "brake_hydr_actual"
#define CAN1_DV_DRIVING_DYNAMICS_1_BRAKE_HYDR_TARGET_NAME "brake_hydr_target"
#define CAN1_DV_DRIVING_DYNAMICS_1_MOTOR_MOMENT_ACTUAL_NAME "motor_moment_actual"
#define CAN1_DV_DRIVING_DYNAMICS_1_MOTOR_MOMENT_TARGET_NAME "motor_moment_target"
#define CAN1_DV_DRIVING_DYNAMICS_2_ACCELERATION_LONGITUDINAL_NAME "acceleration_longitudinal"
#define CAN1_DV_DRIVING_DYNAMICS_2_ACCELERATION_LATERAL_NAME "acceleration_lateral"
#define CAN1_DV_DRIVING_DYNAMICS_2_YAW_RATE_NAME "yaw_rate"
#define CAN1_DV_SYSTEM_STATUS_AS_STATE_NAME "as_state"
#define CAN1_DV_SYSTEM_STATUS_EBS_STATE_NAME "ebs_state"
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_NAME "ami_state"
#define CAN1_DV_SYSTEM_STATUS_STEERING_STATE_NAME "steering_state"
#define CAN1_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_NAME "service_brake_state"
#define CAN1_DV_SYSTEM_STATUS_LAP_COUNTER_NAME "lap_counter"
#define CAN1_DV_SYSTEM_STATUS_CONES_COUNT_ACTUAL_NAME "cones_count_actual"
#define CAN1_DV_SYSTEM_STATUS_CONES_COUNT_ALL_NAME "cones_count_all"
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_BRAKE_LIGHT_NAME "brake_light"
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_R2D_SOUND_NAME "r2d_sound"
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_ASSI_YELLOW_RIGHT_NAME "assi_yellow_right"
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_ASSI_YELLOW_LEFT_NAME "assi_yellow_left"
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_ASSI_YELLOW_REAR_NAME "assi_yellow_rear"
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_ASSI_BLUE_RIGHT_NAME "assi_blue_right"
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_ASSI_BLUE_LEFT_NAME "assi_blue_left"
#define CAN1_MCU_SET_ECU_INDICATOR_POINTS_ASSI_BLUE_REAR_NAME "assi_blue_rear"
#define CAN1_MCU_SET_DBU_INDICATOR_POINTS_TS_INDICATOR_ON_NAME "ts_indicator_on"
#define CAN1_MCU_SET_DBU_INDICATOR_POINTS_R2D_INDICATOR_ON_NAME "r2d_indicator_on"
#define CAN1_RES_STATUS_E_STOP_NAME "e_stop"
#define CAN1_RES_STATUS_SWITCH_STATUS_NAME "switch_status"
#define CAN1_RES_STATUS_BUTTON_STATUS_NAME "button_status"
#define CAN1_RES_STATUS_E_STOP_REDUNDANCY_NAME "e_stop_redundancy"
#define CAN1_RES_STATUS_RADIO_QUALITY_NAME "radio_quality"
#define CAN1_RES_STATUS_RADIO_STATE_NAME "radio_state"
#define CAN1_RES_INITIALIZATION_RES_INIT_NAME "res_init"
#define CAN1_RES_NMT_NODE_CONTROL_REQUESTED_STATE_NAME "requested_state"
#define CAN1_RES_NMT_NODE_CONTROL_NODE_ID_NAME "node_id"
#define CAN1_SWU_STATUS_BUTTON_1_NAME "button_1"
#define CAN1_SWU_STATUS_BUTTON_2_NAME "button_2"
#define CAN1_SWU_STATUS_BUTTON_3_NAME "button_3"
#define CAN1_SWU_STATUS_BUTTON_4_NAME "button_4"
#define CAN1_SWU_STATUS_BUTTON_5_NAME "button_5"
#define CAN1_SWU_STATUS_BUTTON_6_NAME "button_6"
#define CAN1_SWU_STATUS_ROTARY_SWITCH_1_NAME "rotary_switch_1"
#define CAN1_SWU_STATUS_ROTARY_SWITCH_2_NAME "rotary_switch_2"
#define CAN1_SWU_STATUS_ROTARY_SWITCH_3_NAME "rotary_switch_3"
#define CAN1_SWU_STATUS_ROTARY_SWITCH_4_NAME "rotary_switch_4"
#define CAN1_SWU_STATUS_ENCODER_1_BUTTON_NAME "encoder_1_button"
#define CAN1_SWU_STATUS_ENCODER_2_BUTTON_NAME "encoder_2_button"
#define CAN1_SWU_STATUS_ENCODER_1_NAME "encoder_1"
#define CAN1_SWU_STATUS_ENCODER_2_NAME "encoder_2"
#define CAN1_DBU_STATUS_1_ACTIVATE_TS_BUTTON_NAME "activate_ts_button"
#define CAN1_DBU_STATUS_1_READY_TO_DRIVE_BUTTON_NAME "ready_to_drive_button"
#define CAN1_DBU_STATUS_1_SELECTED_MISSION_NAME "selected_mission"
#define CAN1_DBU_STATUS_1_DBU_TEMPERATURE_NAME "dbu_temperature"
#define CAN1_LV_POWER_SIGNAL_LV_ON_NAME "lv_on"
#define CAN1_LV_BMS_DATA_A_DATA_MULTIPLEXOR_NAME "data_multiplexor"
#define CAN1_LV_BMS_DATA_A_VOLTAGE_CELL_1_NAME "voltage_cell_1"
#define CAN1_LV_BMS_DATA_A_SOC_1_NAME "soc_1"
#define CAN1_LV_BMS_DATA_A_THERM1_NAME "therm1"
#define CAN1_LV_BMS_DATA_A_CURRENT_NAME "current"
#define CAN1_LV_BMS_DATA_A_VOLTAGE_CELL_2_NAME "voltage_cell_2"
#define CAN1_LV_BMS_DATA_A_SOC_2_NAME "soc_2"
#define CAN1_LV_BMS_DATA_A_THERM2_NAME "therm2"
#define CAN1_LV_BMS_DATA_A_CURRENT_COUNT_NAME "current_count"
#define CAN1_LV_BMS_DATA_A_VOLTAGE_CELL_3_NAME "voltage_cell_3"
#define CAN1_LV_BMS_DATA_A_SOC_3_NAME "soc_3"
#define CAN1_LV_BMS_DATA_A_VOLTAGE_CELL_4_NAME "voltage_cell_4"
#define CAN1_LV_BMS_DATA_A_SOC_4_NAME "soc_4"
#define CAN1_LV_BMS_DATA_A_THERM3_NAME "therm3"
#define CAN1_LV_BMS_DATA_A_VOLTAGE_CELL_5_NAME "voltage_cell_5"
#define CAN1_LV_BMS_DATA_A_SOC_5_NAME "soc_5"
#define CAN1_LV_BMS_DATA_A_THERM4_NAME "therm4"
#define CAN1_LV_BMS_DATA_A_ENERGY_COUNT_NAME "energy_count"
#define CAN1_LV_BMS_DATA_A_VOLTAGE_CELL_6_NAME "voltage_cell_6"
#define CAN1_LV_BMS_DATA_A_SOC_6_NAME "soc_6"
#define CAN1_LV_BMS_DATA_A_THERM5_NAME "therm5"
#define CAN1_LV_BMS_STATUS_A_LV_BMS_ERROR_NAME "lv_bms_error"
#define CAN1_LV_BMS_STATUS_A_SOC_NAME "soc"
#define CAN1_LV_BMS_STATUS_A_CURRENT_NAME "current"
#define CAN1_LV_BMS_STATUS_A_VOLTAGE_NAME "voltage"
#define CAN1_LV_BMS_STATUS_A_TEMPERATURE_NAME "temperature"
#define CAN1_LV_BMS_STATUS_A_NOT_BATTERY_OUTPUT_ENABLE_NAME "not_battery_output_enable"
#define CAN1_AMS_TEMPERATURES_PRE_CHARGE_RESISTOR_TEMPERATURE_NAME "pre_charge_resistor_temperature"
#define CAN1_AMS_TEMPERATURES_FUSE_RESISTOR_TEMPERATURE_NAME "fuse_resistor_temperature"
#define CAN1_AMS_TEMPERATURES_AUX_1_TEMPERATURE_NAME "aux_1_temperature"
#define CAN1_AMS_TEMPERATURES_AUX_2_TEMPERATURE_NAME "aux_2_temperature"
#define CAN1_AMS_CELL_VOLTAGES_VOLTAGE_MULTIPLEXOR_NAME "voltage_multiplexor"
#define CAN1_AMS_CELL_VOLTAGES_V1S1_NAME "v1s1"
#define CAN1_AMS_CELL_VOLTAGES_V7S1_NAME "v7s1"
#define CAN1_AMS_CELL_VOLTAGES_V1S2_NAME "v1s2"
#define CAN1_AMS_CELL_VOLTAGES_V7S2_NAME "v7s2"
#define CAN1_AMS_CELL_VOLTAGES_V1S3_NAME "v1s3"
#define CAN1_AMS_CELL_VOLTAGES_V7S3_NAME "v7s3"
#define CAN1_AMS_CELL_VOLTAGES_V1S4_NAME "v1s4"
#define CAN1_AMS_CELL_VOLTAGES_V7S4_NAME "v7s4"
#define CAN1_AMS_CELL_VOLTAGES_V1S5_NAME "v1s5"
#define CAN1_AMS_CELL_VOLTAGES_V7S5_NAME "v7s5"
#define CAN1_AMS_CELL_VOLTAGES_V1S6_NAME "v1s6"
#define CAN1_AMS_CELL_VOLTAGES_V7S6_NAME "v7s6"
#define CAN1_AMS_CELL_VOLTAGES_V1S7_NAME "v1s7"
#define CAN1_AMS_CELL_VOLTAGES_V7S7_NAME "v7s7"
#define CAN1_AMS_CELL_VOLTAGES_V1S8_NAME "v1s8"
#define CAN1_AMS_CELL_VOLTAGES_V7S8_NAME "v7s8"
#define CAN1_AMS_CELL_VOLTAGES_V1S9_NAME "v1s9"
#define CAN1_AMS_CELL_VOLTAGES_V7S9_NAME "v7s9"
#define CAN1_AMS_CELL_VOLTAGES_V1S10_NAME "v1s10"
#define CAN1_AMS_CELL_VOLTAGES_V7S10_NAME "v7s10"
#define CAN1_AMS_CELL_VOLTAGES_V1S11_NAME "v1s11"
#define CAN1_AMS_CELL_VOLTAGES_V7S11_NAME "v7s11"
#define CAN1_AMS_CELL_VOLTAGES_V1S12_NAME "v1s12"
#define CAN1_AMS_CELL_VOLTAGES_V7S12_NAME "v7s12"
#define CAN1_AMS_CELL_VOLTAGES_V2S1_NAME "v2s1"
#define CAN1_AMS_CELL_VOLTAGES_V8S1_NAME "v8s1"
#define CAN1_AMS_CELL_VOLTAGES_V2S2_NAME "v2s2"
#define CAN1_AMS_CELL_VOLTAGES_V8S2_NAME "v8s2"
#define CAN1_AMS_CELL_VOLTAGES_V2S3_NAME "v2s3"
#define CAN1_AMS_CELL_VOLTAGES_V8S3_NAME "v8s3"
#define CAN1_AMS_CELL_VOLTAGES_V2S4_NAME "v2s4"
#define CAN1_AMS_CELL_VOLTAGES_V8S4_NAME "v8s4"
#define CAN1_AMS_CELL_VOLTAGES_V2S5_NAME "v2s5"
#define CAN1_AMS_CELL_VOLTAGES_V8S5_NAME "v8s5"
#define CAN1_AMS_CELL_VOLTAGES_V2S6_NAME "v2s6"
#define CAN1_AMS_CELL_VOLTAGES_V8S6_NAME "v8s6"
#define CAN1_AMS_CELL_VOLTAGES_V2S7_NAME "v2s7"
#define CAN1_AMS_CELL_VOLTAGES_V8S7_NAME "v8s7"
#define CAN1_AMS_CELL_VOLTAGES_V2S8_NAME "v2s8"
#define CAN1_AMS_CELL_VOLTAGES_V8S8_NAME "v8s8"
#define CAN1_AMS_CELL_VOLTAGES_V2S9_NAME "v2s9"
#define CAN1_AMS_CELL_VOLTAGES_V8S9_NAME "v8s9"
#define CAN1_AMS_CELL_VOLTAGES_V2S10_NAME "v2s10"
#define CAN1_AMS_CELL_VOLTAGES_V8S10_NAME "v8s10"
#define CAN1_AMS_CELL_VOLTAGES_V2S11_NAME "v2s11"
#define CAN1_AMS_CELL_VOLTAGES_V8S11_NAME "v8s11"
#define CAN1_AMS_CELL_VOLTAGES_V2S12_NAME "v2s12"
#define CAN1_AMS_CELL_VOLTAGES_V8S12_NAME "v8s12"
#define CAN1_AMS_CELL_VOLTAGES_V3S1_NAME "v3s1"
#define CAN1_AMS_CELL_VOLTAGES_V9S1_NAME "v9s1"
#define CAN1_AMS_CELL_VOLTAGES_V3S2_NAME "v3s2"
#define CAN1_AMS_CELL_VOLTAGES_V9S2_NAME "v9s2"
#define CAN1_AMS_CELL_VOLTAGES_V3S3_NAME "v3s3"
#define CAN1_AMS_CELL_VOLTAGES_V9S3_NAME "v9s3"
#define CAN1_AMS_CELL_VOLTAGES_V3S4_NAME "v3s4"
#define CAN1_AMS_CELL_VOLTAGES_V9S4_NAME "v9s4"
#define CAN1_AMS_CELL_VOLTAGES_V3S5_NAME "v3s5"
#define CAN1_AMS_CELL_VOLTAGES_V9S5_NAME "v9s5"
#define CAN1_AMS_CELL_VOLTAGES_V3S6_NAME "v3s6"
#define CAN1_AMS_CELL_VOLTAGES_V9S6_NAME "v9s6"
#define CAN1_AMS_CELL_VOLTAGES_V3S7_NAME "v3s7"
#define CAN1_AMS_CELL_VOLTAGES_V9S7_NAME "v9s7"
#define CAN1_AMS_CELL_VOLTAGES_V3S8_NAME "v3s8"
#define CAN1_AMS_CELL_VOLTAGES_V9S8_NAME "v9s8"
#define CAN1_AMS_CELL_VOLTAGES_V3S9_NAME "v3s9"
#define CAN1_AMS_CELL_VOLTAGES_V9S9_NAME "v9s9"
#define CAN1_AMS_CELL_VOLTAGES_V3S10_NAME "v3s10"
#define CAN1_AMS_CELL_VOLTAGES_V9S10_NAME "v9s10"
#define CAN1_AMS_CELL_VOLTAGES_V3S11_NAME "v3s11"
#define CAN1_AMS_CELL_VOLTAGES_V9S11_NAME "v9s11"
#define CAN1_AMS_CELL_VOLTAGES_V3S12_NAME "v3s12"
#define CAN1_AMS_CELL_VOLTAGES_V9S12_NAME "v9s12"
#define CAN1_AMS_CELL_VOLTAGES_V4S1_NAME "v4s1"
#define CAN1_AMS_CELL_VOLTAGES_V10S1_NAME "v10s1"
#define CAN1_AMS_CELL_VOLTAGES_V4S2_NAME "v4s2"
#define CAN1_AMS_CELL_VOLTAGES_V10S2_NAME "v10s2"
#define CAN1_AMS_CELL_VOLTAGES_V4S3_NAME "v4s3"
#define CAN1_AMS_CELL_VOLTAGES_V10S3_NAME "v10s3"
#define CAN1_AMS_CELL_VOLTAGES_V4S4_NAME "v4s4"
#define CAN1_AMS_CELL_VOLTAGES_V10S4_NAME "v10s4"
#define CAN1_AMS_CELL_VOLTAGES_V4S5_NAME "v4s5"
#define CAN1_AMS_CELL_VOLTAGES_V10S5_NAME "v10s5"
#define CAN1_AMS_CELL_VOLTAGES_V4S6_NAME "v4s6"
#define CAN1_AMS_CELL_VOLTAGES_V10S6_NAME "v10s6"
#define CAN1_AMS_CELL_VOLTAGES_V4S7_NAME "v4s7"
#define CAN1_AMS_CELL_VOLTAGES_V10S7_NAME "v10s7"
#define CAN1_AMS_CELL_VOLTAGES_V4S8_NAME "v4s8"
#define CAN1_AMS_CELL_VOLTAGES_V10S8_NAME "v10s8"
#define CAN1_AMS_CELL_VOLTAGES_V4S9_NAME "v4s9"
#define CAN1_AMS_CELL_VOLTAGES_V10S9_NAME "v10s9"
#define CAN1_AMS_CELL_VOLTAGES_V4S10_NAME "v4s10"
#define CAN1_AMS_CELL_VOLTAGES_V10S10_NAME "v10s10"
#define CAN1_AMS_CELL_VOLTAGES_V4S11_NAME "v4s11"
#define CAN1_AMS_CELL_VOLTAGES_V10S11_NAME "v10s11"
#define CAN1_AMS_CELL_VOLTAGES_V4S12_NAME "v4s12"
#define CAN1_AMS_CELL_VOLTAGES_V10S12_NAME "v10s12"
#define CAN1_AMS_CELL_VOLTAGES_V5S1_NAME "v5s1"
#define CAN1_AMS_CELL_VOLTAGES_V11S1_NAME "v11s1"
#define CAN1_AMS_CELL_VOLTAGES_V5S2_NAME "v5s2"
#define CAN1_AMS_CELL_VOLTAGES_V5S3_NAME "v5s3"
#define CAN1_AMS_CELL_VOLTAGES_V11S3_NAME "v11s3"
#define CAN1_AMS_CELL_VOLTAGES_V5S4_NAME "v5s4"
#define CAN1_AMS_CELL_VOLTAGES_V5S5_NAME "v5s5"
#define CAN1_AMS_CELL_VOLTAGES_V11S5_NAME "v11s5"
#define CAN1_AMS_CELL_VOLTAGES_V5S6_NAME "v5s6"
#define CAN1_AMS_CELL_VOLTAGES_V5S7_NAME "v5s7"
#define CAN1_AMS_CELL_VOLTAGES_V11S7_NAME "v11s7"
#define CAN1_AMS_CELL_VOLTAGES_V5S8_NAME "v5s8"
#define CAN1_AMS_CELL_VOLTAGES_V5S9_NAME "v5s9"
#define CAN1_AMS_CELL_VOLTAGES_V11S9_NAME "v11s9"
#define CAN1_AMS_CELL_VOLTAGES_V5S10_NAME "v5s10"
#define CAN1_AMS_CELL_VOLTAGES_V5S11_NAME "v5s11"
#define CAN1_AMS_CELL_VOLTAGES_V11S11_NAME "v11s11"
#define CAN1_AMS_CELL_VOLTAGES_V5S12_NAME "v5s12"
#define CAN1_AMS_CELL_VOLTAGES_V6S1_NAME "v6s1"
#define CAN1_AMS_CELL_VOLTAGES_V6S2_NAME "v6s2"
#define CAN1_AMS_CELL_VOLTAGES_V6S3_NAME "v6s3"
#define CAN1_AMS_CELL_VOLTAGES_V6S4_NAME "v6s4"
#define CAN1_AMS_CELL_VOLTAGES_V6S5_NAME "v6s5"
#define CAN1_AMS_CELL_VOLTAGES_V6S6_NAME "v6s6"
#define CAN1_AMS_CELL_VOLTAGES_V6S7_NAME "v6s7"
#define CAN1_AMS_CELL_VOLTAGES_V6S8_NAME "v6s8"
#define CAN1_AMS_CELL_VOLTAGES_V6S9_NAME "v6s9"
#define CAN1_AMS_CELL_VOLTAGES_V6S10_NAME "v6s10"
#define CAN1_AMS_CELL_VOLTAGES_V6S11_NAME "v6s11"
#define CAN1_AMS_CELL_VOLTAGES_V6S12_NAME "v6s12"
#define CAN1_AMS_CELL_TEMPERATURES_TEMPERATURE_MULTIPLEXOR_NAME "temperature_multiplexor"
#define CAN1_AMS_CELL_TEMPERATURES_T1S1_NAME "t1s1"
#define CAN1_AMS_CELL_TEMPERATURES_T1S2_NAME "t1s2"
#define CAN1_AMS_CELL_TEMPERATURES_T1S3_NAME "t1s3"
#define CAN1_AMS_CELL_TEMPERATURES_T1S4_NAME "t1s4"
#define CAN1_AMS_CELL_TEMPERATURES_T1S5_NAME "t1s5"
#define CAN1_AMS_CELL_TEMPERATURES_T1S6_NAME "t1s6"
#define CAN1_AMS_CELL_TEMPERATURES_T1S7_NAME "t1s7"
#define CAN1_AMS_CELL_TEMPERATURES_T1S8_NAME "t1s8"
#define CAN1_AMS_CELL_TEMPERATURES_T1S9_NAME "t1s9"
#define CAN1_AMS_CELL_TEMPERATURES_T1S10_NAME "t1s10"
#define CAN1_AMS_CELL_TEMPERATURES_T1S11_NAME "t1s11"
#define CAN1_AMS_CELL_TEMPERATURES_T1S12_NAME "t1s12"
#define CAN1_AMS_CELL_TEMPERATURES_T2S1_NAME "t2s1"
#define CAN1_AMS_CELL_TEMPERATURES_T2S2_NAME "t2s2"
#define CAN1_AMS_CELL_TEMPERATURES_T2S3_NAME "t2s3"
#define CAN1_AMS_CELL_TEMPERATURES_T2S4_NAME "t2s4"
#define CAN1_AMS_CELL_TEMPERATURES_T2S5_NAME "t2s5"
#define CAN1_AMS_CELL_TEMPERATURES_T2S6_NAME "t2s6"
#define CAN1_AMS_CELL_TEMPERATURES_T2S7_NAME "t2s7"
#define CAN1_AMS_CELL_TEMPERATURES_T2S8_NAME "t2s8"
#define CAN1_AMS_CELL_TEMPERATURES_T2S9_NAME "t2s9"
#define CAN1_AMS_CELL_TEMPERATURES_T2S10_NAME "t2s10"
#define CAN1_AMS_CELL_TEMPERATURES_T2S11_NAME "t2s11"
#define CAN1_AMS_CELL_TEMPERATURES_T2S12_NAME "t2s12"
#define CAN1_AMS_CELL_TEMPERATURES_T3S1_NAME "t3s1"
#define CAN1_AMS_CELL_TEMPERATURES_T3S2_NAME "t3s2"
#define CAN1_AMS_CELL_TEMPERATURES_T3S3_NAME "t3s3"
#define CAN1_AMS_CELL_TEMPERATURES_T3S4_NAME "t3s4"
#define CAN1_AMS_CELL_TEMPERATURES_T3S5_NAME "t3s5"
#define CAN1_AMS_CELL_TEMPERATURES_T3S6_NAME "t3s6"
#define CAN1_AMS_CELL_TEMPERATURES_T3S7_NAME "t3s7"
#define CAN1_AMS_CELL_TEMPERATURES_T3S8_NAME "t3s8"
#define CAN1_AMS_CELL_TEMPERATURES_T3S9_NAME "t3s9"
#define CAN1_AMS_CELL_TEMPERATURES_T3S10_NAME "t3s10"
#define CAN1_AMS_CELL_TEMPERATURES_T3S11_NAME "t3s11"
#define CAN1_AMS_CELL_TEMPERATURES_T3S12_NAME "t3s12"
#define CAN1_AMS_CELL_TEMPERATURES_T4S1_NAME "t4s1"
#define CAN1_AMS_CELL_TEMPERATURES_T4S2_NAME "t4s2"
#define CAN1_AMS_CELL_TEMPERATURES_T4S3_NAME "t4s3"
#define CAN1_AMS_CELL_TEMPERATURES_T4S4_NAME "t4s4"
#define CAN1_AMS_CELL_TEMPERATURES_T4S5_NAME "t4s5"
#define CAN1_AMS_CELL_TEMPERATURES_T4S6_NAME "t4s6"
#define CAN1_AMS_CELL_TEMPERATURES_T4S7_NAME "t4s7"
#define CAN1_AMS_CELL_TEMPERATURES_T4S8_NAME "t4s8"
#define CAN1_AMS_CELL_TEMPERATURES_T4S9_NAME "t4s9"
#define CAN1_AMS_CELL_TEMPERATURES_T4S10_NAME "t4s10"
#define CAN1_AMS_CELL_TEMPERATURES_T4S11_NAME "t4s11"
#define CAN1_AMS_CELL_TEMPERATURES_T4S12_NAME "t4s12"
#define CAN1_AMS_CELL_TEMPERATURES_T5S1_NAME "t5s1"
#define CAN1_AMS_CELL_TEMPERATURES_T5S2_NAME "t5s2"
#define CAN1_AMS_CELL_TEMPERATURES_T5S3_NAME "t5s3"
#define CAN1_AMS_CELL_TEMPERATURES_T5S4_NAME "t5s4"
#define CAN1_AMS_CELL_TEMPERATURES_T5S5_NAME "t5s5"
#define CAN1_AMS_CELL_TEMPERATURES_T5S6_NAME "t5s6"
#define CAN1_AMS_CELL_TEMPERATURES_T5S7_NAME "t5s7"
#define CAN1_AMS_CELL_TEMPERATURES_T5S8_NAME "t5s8"
#define CAN1_AMS_CELL_TEMPERATURES_T5S9_NAME "t5s9"
#define CAN1_AMS_CELL_TEMPERATURES_T5S10_NAME "t5s10"
#define CAN1_AMS_CELL_TEMPERATURES_T5S11_NAME "t5s11"
#define CAN1_AMS_CELL_TEMPERATURES_T5S12_NAME "t5s12"
#define CAN1_ECU_STATUS_TS_NOT_OFF_NAME "ts_not_off"
#define CAN1_ECU_STATUS_RST_BUTTON_NAME "rst_button"
#define CAN1_ECU_STATUS_SIDEPANEL_ACTIVATE_TS_BUTTON_NAME "sidepanel_activate_ts_button"
#define CAN1_ECU_STATUS_TS_OFF_NAME "ts_off"
#define CAN1_EBS_STATUS_EBS_STATUS_NAME "ebs_status"
#define CAN1_EBS_STATUS_EBS_STATE_MACHINE_NAME "ebs_state_machine"
#define CAN1_EBS_STATUS_EBS_ERROR_NAME "ebs_error"
#define CAN1_EBS_STATUS_SDC_STATUS_NAME "SDC_STATUS"
#define CAN1_EBS_STATUS_EBS_PRESSURE_1_NAME "ebs_pressure_1"
#define CAN1_EBS_STATUS_EBS_PRESSURE_2_NAME "ebs_pressure_2"
#define CAN1_EBS_STATUS_BRAKE_PRESSURE_FRONT_NAME "brake_pressure_front"
#define CAN1_EBS_STATUS_BRAKE_PRESSURE_REAR_NAME "brake_pressure_rear"
#define CAN1_FB_PEDALS_APPS_1_NAME "apps_1"
#define CAN1_FB_PEDALS_APPS_2_NAME "apps_2"
#define CAN1_FB_PEDALS_BPPS_1_NAME "bpps_1"
#define CAN1_FB_PEDALS_BPPS_2_NAME "bpps_2"
#define CAN1_FB_PEDALS_BPPS_ERROR_NAME "bpps_error"
#define CAN1_FB_PEDALS_APPS_ERROR_NAME "apps_error"
#define CAN1_MCU_SET_CCU_COOLING_POINTS_FAN1_SPEED_NAME "fan1_speed"
#define CAN1_MCU_SET_CCU_COOLING_POINTS_FAN2_SPEED_NAME "fan2_speed"
#define CAN1_MCU_SET_CCU_COOLING_POINTS_FAN3_SPEED_NAME "fan3_speed"
#define CAN1_MCU_SET_CCU_COOLING_POINTS_PUMP1_SPEED_NAME "pump1_speed"
#define CAN1_MCU_SET_CCU_COOLING_POINTS_PUMP2_SPEED_NAME "pump2_speed"
#define CAN1_MCU_SET_CCU_COOLING_POINTS_PUMP3_SPEED_NAME "pump3_speed"
#define CAN1_CCU_STATUS_1_MUX_ID_NAME "mux_ID"
#define CAN1_CCU_STATUS_1_FAN1_TEMPERATURE_NAME "fan1_temperature"
#define CAN1_CCU_STATUS_1_FAN2_TEMPERATURE_NAME "fan2_temperature"
#define CAN1_CCU_STATUS_1_FAN3_TEMPERATURE_NAME "fan3_temperature"
#define CAN1_CCU_STATUS_1_FRON_PUMP_TEMPERATURE_NAME "fron_pump_temperature"
#define CAN1_CCU_STATUS_1_REAR_PUMP_TEMPERATURE_NAME "rear_pump_temperature"
#define CAN1_CCU_STATUS_1_INVERTER_PUMP_TEMPERATURE_NAME "inverter_pump_temperature"
#define CAN1_CCU_STATUS_2_DIGITAL_INPUT_NAME "digital_input"
#define CAN1_CCU_STATUS_2_DISCHARGE_RELAY_OPEN_NAME "discharge_relay_open"
#define CAN1_CCU_STATUS_2_DISCHARGE_RESISTOR_TEMPERATURE_NAME "discharge_resistor_temperature"
#define CAN1_CCU_STATUS_2_EXTRA_TEMPERATURE_NAME "extra_temperature"
#define CAN1_VEHICLE_STATUS_CAR_STATE_NAME "car_state"
#define CAN1_VEHICLE_STATUS_CAR_VELOCITY_NAME "car_velocity"
#define CAN1_VEHICLE_STATUS_CAR_POWER_NAME "car_power"
#define CAN1_VEHICLE_STATUS_CAR_REGEN_LEVEL_NAME "car_regen_level"
#define CAN1_VEHICLE_STATUS_READY_TO_DRIVE_NAME "ready_to_drive"
#define CAN1_VEHICLE_STATUS_TORQUE_VECTORING_ACTIVE_NAME "Torque_vectoring_active"
#define CAN1_VEHICLE_STATUS_TRACTION_CONTROL_ON_NAME "Traction_control_on"
#define CAN1_VEHICLE_STATUS_ABS_ON_NAME "ABS_on"
#define CAN1_FAULT_UNIT_ID_NAME "unit_id"
#define CAN1_FAULT_APPS_DISCREPANCY_NAME "apps_discrepancy"
#define CAN1_FAULT_SC_OPEN_NAME "sc_open"
#define CAN1_FAULT_TS_OFF_WATCHDOG_TRIGGERED_NAME "ts_off_watchdog_triggered"
#define CAN1_FAULT_BPPS_DISCREPANCY_NAME "bpps_discrepancy"
#define CAN1_FAULT_BRAKE_PRESSURE_DISCREPANCY_NAME "brake_pressure_discrepancy"
#define CAN1_FAULT_STEERING_ANGLE_DISCREPANCY_NAME "steering_angle_discrepancy"
#define CAN1_FAULT_APPS_OUT_OF_RANGE_NAME "apps_out_of_range"
#define CAN1_FAULT_BPPS_OUT_OF_RANGE_NAME "bpps_out_of_range"
#define CAN1_FAULT_BRAKE_PRESSURE_OUT_OF_RANGE_NAME "brake_pressure_out_of_range"
#define CAN1_FAULT_STEERING_ANGLE_OUT_OF_RANGE_NAME "steering_angle_out_of_range"
#define CAN1_STEERING_STEERING_ANGLE_1_NAME "steering_angle_1"
#define CAN1_STEERING_STEERING_ANGLE_2_NAME "steering_angle_2"
#define CAN1_STEERING_STEERING_ANGLE_NAME "steering_angle"
#define CAN1_STEERING_STEERING_ANGLE_NORMALIZED_NAME "steering_angle_normalized"
#define CAN1_STEERING_STEERING_ANGLE_ERROR_NAME "steering_angle_error"
#define CAN1_DBU_STATUS_2_SCREEN_ID_NAME "screen_id"
#define CAN1_DV_CONTROL_TARGET_DV_SPEED_TARGET_NAME "dv_speed_target"
#define CAN1_DV_CONTROL_TARGET_DV_STEERING_ANGLE_TARGET_NAME "dv_steering_angle_target"
#define CAN1_DV_CONTROL_TARGET_DV_BRAKE_HYDRALIC_TARGET_NAME "dv_brake_hydralic_target"
#define CAN1_DV_CONTROL_TARGET_DV_MOTOR_MOMENT_TARGET_NAME "dv_motor_moment_target"
#define CAN1_DV_CONTROL_TARGET_DV_MISSION_STATUS_NAME "dv_mission_status"
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_WHEEL_SPEED_FL_NAME "wheel_speed_fl"
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_WHEEL_SPEED_FR_NAME "wheel_speed_fr"
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_WHEEL_SPEED_RL_NAME "wheel_speed_rl"
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_WHEEL_SPEED_RR_NAME "wheel_speed_rr"
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_TRUE_HEADING_NAME "TRUE_HEADING"
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_TRUE_HEADING_ACC_NAME "TRUE_HEADING_ACC"
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_PITCH_NAME "PITCH"
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_PITCH_ACC_NAME "PITCH_ACC"
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_INFO_TIME_STAMP_NAME "TIME_STAMP"
#define CAN1_SBG_ECAN_MSG_GPS2_HDT_INFO_STATUS_NAME "STATUS"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ACC_LATITUDE_ACC_NAME "LATITUDE_ACC"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ACC_LONGITUDE_ACC_NAME "LONGITUDE_ACC"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ACC_ALTITUDE_ACC_NAME "ALTITUDE_ACC"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ACC_BASE_STATION_ID_NAME "BASE_STATION_ID"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ALT_ALTITUDE_NAME "ALTITUDE"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ALT_UNDULATION_NAME "UNDULATION"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ALT_NUM_SV_NAME "NUM_SV"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_ALT_DIFF_CORR_AGE_NAME "DIFF_CORR_AGE"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_LATITUDE_NAME "LATITUDE"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_LONGITUDE_NAME "LONGITUDE"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_INFO_TIME_STAMP_NAME "TIME_STAMP"
#define CAN1_SBG_ECAN_MSG_GPS2_POS_INFO_STATUS_NAME "STATUS"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_COURSE_COURSE_NAME "COURSE"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_COURSE_COURSE_ACC_NAME "COURSE_ACC"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_ACC_VELOCITY_ACC_N_NAME "VELOCITY_ACC_N"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_ACC_VELOCITY_ACC_E_NAME "VELOCITY_ACC_E"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_ACC_VELOCITY_ACC_D_NAME "VELOCITY_ACC_D"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_VELOCITY_N_NAME "VELOCITY_N"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_VELOCITY_E_NAME "VELOCITY_E"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_VELOCITY_D_NAME "VELOCITY_D"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_INFO_TIME_STAMP_NAME "TIME_STAMP"
#define CAN1_SBG_ECAN_MSG_GPS2_VEL_INFO_STATUS_NAME "STATUS"
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_TRUE_HEADING_NAME "TRUE_HEADING"
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_TRUE_HEADING_ACC_NAME "TRUE_HEADING_ACC"
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_PITCH_NAME "PITCH"
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_PITCH_ACC_NAME "PITCH_ACC"
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_INFO_TIME_STAMP_NAME "TIME_STAMP"
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_INFO_STATUS_NAME "STATUS"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ACC_LATITUDE_ACC_NAME "LATITUDE_ACC"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ACC_LONGITUDE_ACC_NAME "LONGITUDE_ACC"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ACC_ALTITUDE_ACC_NAME "ALTITUDE_ACC"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ACC_BASE_STATION_ID_NAME "BASE_STATION_ID"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ALT_ALTITUDE_NAME "ALTITUDE"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ALT_UNDULATION_NAME "UNDULATION"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ALT_NUM_SV_NAME "NUM_SV"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_ALT_DIFF_CORR_AGE_NAME "DIFF_CORR_AGE"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_LATITUDE_NAME "LATITUDE"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_LONGITUDE_NAME "LONGITUDE"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_INFO_TIME_STAMP_NAME "TIME_STAMP"
#define CAN1_SBG_ECAN_MSG_GPS1_POS_INFO_STATUS_NAME "STATUS"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_COURSE_COURSE_NAME "COURSE"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_COURSE_COURSE_ACC_NAME "COURSE_ACC"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_ACC_VELOCITY_ACC_N_NAME "VELOCITY_ACC_N"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_ACC_VELOCITY_ACC_E_NAME "VELOCITY_ACC_E"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_ACC_VELOCITY_ACC_D_NAME "VELOCITY_ACC_D"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_VELOCITY_N_NAME "VELOCITY_N"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_VELOCITY_E_NAME "VELOCITY_E"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_VELOCITY_D_NAME "VELOCITY_D"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_INFO_TIME_STAMP_NAME "TIME_STAMP"
#define CAN1_SBG_ECAN_MSG_GPS1_VEL_INFO_STATUS_NAME "STATUS"
#define CAN1_SBG_ECAN_MSG_ODO_VEL_VELOCITY_NAME "VELOCITY"
#define CAN1_SBG_ECAN_MSG_ODO_INFO_TIME_STAMP_NAME "TIME_STAMP"
#define CAN1_SBG_ECAN_MSG_ODO_INFO_ODO_STATUS_NAME "ODO_STATUS"
#define CAN1_SBG_ECAN_MSG_EKF_VEL_BODY_VELOCITY_X_NAME "VELOCITY_X"
#define CAN1_SBG_ECAN_MSG_EKF_VEL_BODY_VELOCITY_Y_NAME "VELOCITY_Y"
#define CAN1_SBG_ECAN_MSG_EKF_VEL_BODY_VELOCITY_Z_NAME "VELOCITY_Z"
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_VELOCITY_ACC_N_NAME "VELOCITY_ACC_N"
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_VELOCITY_ACC_E_NAME "VELOCITY_ACC_E"
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_VELOCITY_ACC_D_NAME "VELOCITY_ACC_D"
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_VELOCITY_N_NAME "VELOCITY_N"
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_VELOCITY_E_NAME "VELOCITY_E"
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_VELOCITY_D_NAME "VELOCITY_D"
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_LATITUDE_ACC_NAME "LATITUDE_ACC"
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_LONGITUDE_ACC_NAME "LONGITUDE_ACC"
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_ALTITUDE_ACC_NAME "ALTITUDE_ACC"
#define CAN1_SBG_ECAN_MSG_EKF_POS_LATITUDE_NAME "LATITUDE"
#define CAN1_SBG_ECAN_MSG_EKF_POS_LONGITUDE_NAME "LONGITUDE"
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_ROLL_ACC_NAME "ROLL_ACC"
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_PITCH_ACC_NAME "PITCH_ACC"
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_YAW_ACC_NAME "YAW_ACC"
#define CAN1_SBG_ECAN_MSG_EKF_EULER_ROLL_NAME "ROLL"
#define CAN1_SBG_ECAN_MSG_EKF_EULER_PITCH_NAME "PITCH"
#define CAN1_SBG_ECAN_MSG_EKF_EULER_YAW_NAME "YAW"
#define CAN1_SBG_ECAN_MSG_EKF_QUAT_Q0_NAME "Q0"
#define CAN1_SBG_ECAN_MSG_EKF_QUAT_Q1_NAME "Q1"
#define CAN1_SBG_ECAN_MSG_EKF_QUAT_Q2_NAME "Q2"
#define CAN1_SBG_ECAN_MSG_EKF_QUAT_Q3_NAME "Q3"
#define CAN1_SBG_ECAN_MSG_EKF_INFO_TIME_STAMP_NAME "TIME_STAMP"
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_ANGLE_DELTA_ANGLE_X_NAME "DELTA_ANGLE_X"
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_ANGLE_DELTA_ANGLE_Y_NAME "DELTA_ANGLE_Y"
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_ANGLE_DELTA_ANGLE_Z_NAME "DELTA_ANGLE_Z"
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_VEL_DELTA_VEL_X_NAME "DELTA_VEL_X"
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_VEL_DELTA_VEL_Y_NAME "DELTA_VEL_Y"
#define CAN1_SBG_ECAN_MSG_IMU_DELTA_VEL_DELTA_VEL_Z_NAME "DELTA_VEL_Z"
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_GYRO_X_NAME "GYRO_X"
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_GYRO_Y_NAME "GYRO_Y"
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_GYRO_Z_NAME "GYRO_Z"
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_ACCEL_X_NAME "ACCEL_X"
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_ACCEL_Y_NAME "ACCEL_Y"
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_ACCEL_Z_NAME "ACCEL_Z"
#define CAN1_SBG_ECAN_MSG_IMU_INFO_TIME_STAMP_NAME "TIME_STAMP"
#define CAN1_SBG_ECAN_MSG_IMU_INFO_STATUS_NAME "STATUS"
#define CAN1_SBG_ECAN_MSG_IMU_INFO_TEMPERATURE_NAME "TEMPERATURE"
#define CAN1_SBG_ECAN_MSG_UTC_1_YEAR_NAME "YEAR"
#define CAN1_SBG_ECAN_MSG_UTC_1_MONTH_NAME "MONTH"
#define CAN1_SBG_ECAN_MSG_UTC_1_DAY_NAME "DAY"
#define CAN1_SBG_ECAN_MSG_UTC_1_HOUR_NAME "HOUR"
#define CAN1_SBG_ECAN_MSG_UTC_1_MIN_NAME "MIN"
#define CAN1_SBG_ECAN_MSG_UTC_1_SEC_NAME "SEC"
#define CAN1_SBG_ECAN_MSG_UTC_1_MICRO_SEC_NAME "MICRO_SEC"
#define CAN1_SBG_ECAN_MSG_UTC_0_TIME_STAMP_NAME "TIME_STAMP"
#define CAN1_SBG_ECAN_MSG_UTC_0_GPS_TOW_NAME "GPS_TOW"
#define CAN1_FS_DATALOGGER_STATUS_MSG_CNT_NAME "MsgCnt"
#define CAN1_FS_DATALOGGER_STATUS_STATUS_READY_NAME "Status_Ready"
#define CAN1_FS_DATALOGGER_STATUS_STATUS_LOGGING_NAME "Status_Logging"
#define CAN1_FS_DATALOGGER_STATUS_STATUS_TRIGGERED_VOLTAGE_NAME "Status_Triggered_Voltage"
#define CAN1_FS_DATALOGGER_STATUS_STATUS_TRIGGERED_CURRENT_NAME "Status_Triggered_Current"
#define CAN1_FS_DATALOGGER_STATUS_VOLTAGE_NAME "Voltage"
#define CAN1_FS_DATALOGGER_STATUS_CURRENT_NAME "Current"
#define CAN1_VESC_STATUS_2_AMP_HOURS_NAME "Amp_Hours"
#define CAN1_VESC_STATUS_2_AMP_HOURS_CHG_NAME "Amp_Hours_Chg"
#define CAN1_VESC_STATUS_4_TEMP_FET_NAME "Temp_FET"
#define CAN1_VESC_STATUS_4_TEMP_MOTOR_NAME "Temp_Motor"
#define CAN1_VESC_STATUS_4_CURRENT_IN_NAME "Current_In"
#define CAN1_VESC_STATUS_4_PID_POS_NAME "PID_Pos"
#define CAN1_VESC_STATUS_5_TACHOMETER_NAME "Tachometer"
#define CAN1_VESC_STATUS_5_VOLTS_IN_NAME "Volts_In"
#define CAN1_VESC_STATUS_6_ADC1_NAME "ADC1"
#define CAN1_VESC_STATUS_6_ADC2_NAME "ADC2"
#define CAN1_VESC_STATUS_6_ADC3_NAME "ADC3"
#define CAN1_VESC_STATUS_6_PPM_NAME "PPM"
#define CAN1_VESC_SET_DUTY_SET_DUTY_NAME "Set_Duty"
#define CAN1_VESC_STATUS_ERPM_NAME "ERPM"
#define CAN1_VESC_STATUS_CURRENT_NAME "Current"
#define CAN1_VESC_STATUS_DUTY_CYCLE_NAME "DutyCycle"
#define CAN1_AMS_S1_VOLTAGES_1_S1V1_NAME "s1v1"
#define CAN1_AMS_S1_VOLTAGES_1_S1V2_NAME "s1v2"
#define CAN1_AMS_S1_VOLTAGES_1_S1V3_NAME "s1v3"
#define CAN1_AMS_S1_VOLTAGES_1_S1V4_NAME "s1v4"
#define CAN1_AMS_S1_VOLTAGES_1_S1V5_NAME "s1v5"
#define CAN1_AMS_S1_VOLTAGES_1_S1V6_NAME "s1v6"
#define CAN1_AMS_S1_VOLTAGES_2_S1V7_NAME "s1v7"
#define CAN1_AMS_S1_VOLTAGES_2_S1V8_NAME "s1v8"
#define CAN1_AMS_S1_VOLTAGES_2_S1V9_NAME "s1v9"
#define CAN1_AMS_S1_VOLTAGES_2_S1V10_NAME "s1v10"
#define CAN1_AMS_S1_VOLTAGES_2_S1V11_NAME "s1v11"
#define CAN1_AMS_S2_VOLTAGES_1_S2V1_NAME "s2v1"
#define CAN1_AMS_S2_VOLTAGES_1_S2V2_NAME "s2v2"
#define CAN1_AMS_S2_VOLTAGES_1_S2V3_NAME "s2v3"
#define CAN1_AMS_S2_VOLTAGES_1_S2V4_NAME "s2v4"
#define CAN1_AMS_S2_VOLTAGES_1_S2V5_NAME "s2v5"
#define CAN1_AMS_S2_VOLTAGES_1_S2V6_NAME "s2v6"
#define CAN1_AMS_S2_VOLTAGES_2_S2V7_NAME "s2v7"
#define CAN1_AMS_S2_VOLTAGES_2_S2V8_NAME "s2v8"
#define CAN1_AMS_S2_VOLTAGES_2_S2V9_NAME "s2v9"
#define CAN1_AMS_S2_VOLTAGES_2_S2V10_NAME "s2v10"
#define CAN1_AMS_S2_VOLTAGES_2_S2V11_NAME "s2v11"
#define CAN1_AMS_S3_VOLTAGES_1_S3V1_NAME "s3v1"
#define CAN1_AMS_S3_VOLTAGES_1_S3V2_NAME "s3v2"
#define CAN1_AMS_S3_VOLTAGES_1_S3V3_NAME "s3v3"
#define CAN1_AMS_S3_VOLTAGES_1_S3V4_NAME "s3v4"
#define CAN1_AMS_S3_VOLTAGES_1_S3V5_NAME "s3v5"
#define CAN1_AMS_S3_VOLTAGES_1_S3V6_NAME "s3v6"
#define CAN1_AMS_S3_VOLTAGES_2_S3V7_NAME "s3v7"
#define CAN1_AMS_S3_VOLTAGES_2_S3V8_NAME "s3v8"
#define CAN1_AMS_S3_VOLTAGES_2_S3V9_NAME "s3v9"
#define CAN1_AMS_S3_VOLTAGES_2_S3V10_NAME "s3v10"
#define CAN1_AMS_S3_VOLTAGES_2_S3V11_NAME "s3v11"
#define CAN1_AMS_S4_VOLTAGES_1_S4V1_NAME "s4v1"
#define CAN1_AMS_S4_VOLTAGES_1_S4V2_NAME "s4v2"
#define CAN1_AMS_S4_VOLTAGES_1_S4V3_NAME "s4v3"
#define CAN1_AMS_S4_VOLTAGES_1_S4V4_NAME "s4v4"
#define CAN1_AMS_S4_VOLTAGES_1_S4V5_NAME "s4v5"
#define CAN1_AMS_S4_VOLTAGES_1_S4V6_NAME "s4v6"
#define CAN1_AMS_S4_VOLTAGES_2_S4V7_NAME "s4v7"
#define CAN1_AMS_S4_VOLTAGES_2_S4V8_NAME "s4v8"
#define CAN1_AMS_S4_VOLTAGES_2_S4V9_NAME "s4v9"
#define CAN1_AMS_S4_VOLTAGES_2_S4V10_NAME "s4v10"
#define CAN1_AMS_S4_VOLTAGES_2_S4V11_NAME "s4v11"
#define CAN1_AMS_S5_VOLTAGES_1_S5V1_NAME "s5v1"
#define CAN1_AMS_S5_VOLTAGES_1_S5V2_NAME "s5v2"
#define CAN1_AMS_S5_VOLTAGES_1_S5V3_NAME "s5v3"
#define CAN1_AMS_S5_VOLTAGES_1_S5V4_NAME "s5v4"
#define CAN1_AMS_S5_VOLTAGES_1_S5V5_NAME "s5v5"
#define CAN1_AMS_S5_VOLTAGES_1_S5V6_NAME "s5v6"
#define CAN1_AMS_S5_VOLTAGES_2_S5V7_NAME "s5v7"
#define CAN1_AMS_S5_VOLTAGES_2_S5V8_NAME "s5v8"
#define CAN1_AMS_S5_VOLTAGES_2_S5V9_NAME "s5v9"
#define CAN1_AMS_S5_VOLTAGES_2_S5V10_NAME "s5v10"
#define CAN1_AMS_S5_VOLTAGES_2_S5V11_NAME "s5v11"
#define CAN1_AMS_S6_VOLTAGES_1_S6V1_NAME "s6v1"
#define CAN1_AMS_S6_VOLTAGES_1_S6V2_NAME "s6v2"
#define CAN1_AMS_S6_VOLTAGES_1_S6V3_NAME "s6v3"
#define CAN1_AMS_S6_VOLTAGES_1_S6V4_NAME "s6v4"
#define CAN1_AMS_S6_VOLTAGES_1_S6V5_NAME "s6v5"
#define CAN1_AMS_S6_VOLTAGES_1_S6V6_NAME "s6v6"
#define CAN1_AMS_S6_VOLTAGES_2_S6V7_NAME "s6v7"
#define CAN1_AMS_S6_VOLTAGES_2_S6V8_NAME "s6v8"
#define CAN1_AMS_S6_VOLTAGES_2_S6V9_NAME "s6v9"
#define CAN1_AMS_S6_VOLTAGES_2_S6V10_NAME "s6v10"
#define CAN1_AMS_S6_VOLTAGES_2_S6V11_NAME "s6v11"
#define CAN1_AMS_S7_VOLTAGES_1_S7V1_NAME "s7v1"
#define CAN1_AMS_S7_VOLTAGES_1_S7V2_NAME "s7v2"
#define CAN1_AMS_S7_VOLTAGES_1_S7V3_NAME "s7v3"
#define CAN1_AMS_S7_VOLTAGES_1_S7V4_NAME "s7v4"
#define CAN1_AMS_S7_VOLTAGES_1_S7V5_NAME "s7v5"
#define CAN1_AMS_S7_VOLTAGES_1_S7V6_NAME "s7v6"
#define CAN1_AMS_S7_VOLTAGES_2_S7V7_NAME "s7v7"
#define CAN1_AMS_S7_VOLTAGES_2_S7V8_NAME "s7v8"
#define CAN1_AMS_S7_VOLTAGES_2_S7V9_NAME "s7v9"
#define CAN1_AMS_S7_VOLTAGES_2_S7V10_NAME "s7v10"
#define CAN1_AMS_S7_VOLTAGES_2_S7V11_NAME "s7v11"
#define CAN1_AMS_S8_VOLTAGES_1_S8V1_NAME "s8v1"
#define CAN1_AMS_S8_VOLTAGES_1_S8V2_NAME "s8v2"
#define CAN1_AMS_S8_VOLTAGES_1_S8V3_NAME "s8v3"
#define CAN1_AMS_S8_VOLTAGES_1_S8V4_NAME "s8v4"
#define CAN1_AMS_S8_VOLTAGES_1_S8V5_NAME "s8v5"
#define CAN1_AMS_S8_VOLTAGES_1_S8V6_NAME "s8v6"
#define CAN1_AMS_S8_VOLTAGES_2_S8V7_NAME "s8v7"
#define CAN1_AMS_S8_VOLTAGES_2_S8V8_NAME "s8v8"
#define CAN1_AMS_S8_VOLTAGES_2_S8V9_NAME "s8v9"
#define CAN1_AMS_S8_VOLTAGES_2_S8V10_NAME "s8v10"
#define CAN1_AMS_S8_VOLTAGES_2_S8V11_NAME "s8v11"
#define CAN1_AMS_S9_VOLTAGES_1_S9V1_NAME "s9v1"
#define CAN1_AMS_S9_VOLTAGES_1_S9V2_NAME "s9v2"
#define CAN1_AMS_S9_VOLTAGES_1_S9V3_NAME "s9v3"
#define CAN1_AMS_S9_VOLTAGES_1_S9V4_NAME "s9v4"
#define CAN1_AMS_S9_VOLTAGES_1_S9V5_NAME "s9v5"
#define CAN1_AMS_S9_VOLTAGES_1_S9V6_NAME "s9v6"
#define CAN1_AMS_S9_VOLTAGES_2_S9V7_NAME "s9v7"
#define CAN1_AMS_S9_VOLTAGES_2_S9V8_NAME "s9v8"
#define CAN1_AMS_S9_VOLTAGES_2_S9V9_NAME "s9v9"
#define CAN1_AMS_S9_VOLTAGES_2_S9V10_NAME "s9v10"
#define CAN1_AMS_S9_VOLTAGES_2_S9V11_NAME "s9v11"
#define CAN1_AMS_S10_VOLTAGES_1_S10V1_NAME "s10v1"
#define CAN1_AMS_S10_VOLTAGES_1_S10V2_NAME "s10v2"
#define CAN1_AMS_S10_VOLTAGES_1_S10V3_NAME "s10v3"
#define CAN1_AMS_S10_VOLTAGES_1_S10V4_NAME "s10v4"
#define CAN1_AMS_S10_VOLTAGES_1_S10V5_NAME "s10v5"
#define CAN1_AMS_S10_VOLTAGES_1_S10V6_NAME "s10v6"
#define CAN1_AMS_S10_VOLTAGES_2_S10V7_NAME "s10v7"
#define CAN1_AMS_S10_VOLTAGES_2_S10V8_NAME "s10v8"
#define CAN1_AMS_S10_VOLTAGES_2_S10V9_NAME "s10v9"
#define CAN1_AMS_S10_VOLTAGES_2_S10V10_NAME "s10v10"
#define CAN1_AMS_S10_VOLTAGES_2_S10V11_NAME "s10v11"
#define CAN1_AMS_S11_VOLTAGES_1_S11V1_NAME "s11v1"
#define CAN1_AMS_S11_VOLTAGES_1_S11V2_NAME "s11v2"
#define CAN1_AMS_S11_VOLTAGES_1_S11V3_NAME "s11v3"
#define CAN1_AMS_S11_VOLTAGES_1_S11V4_NAME "s11v4"
#define CAN1_AMS_S11_VOLTAGES_1_S11V5_NAME "s11v5"
#define CAN1_AMS_S11_VOLTAGES_1_S11V6_NAME "s11v6"
#define CAN1_AMS_S11_VOLTAGES_2_S11V7_NAME "s11v7"
#define CAN1_AMS_S11_VOLTAGES_2_S11V8_NAME "s11v8"
#define CAN1_AMS_S11_VOLTAGES_2_S11V9_NAME "s11v9"
#define CAN1_AMS_S11_VOLTAGES_2_S11V10_NAME "s11v10"
#define CAN1_AMS_S11_VOLTAGES_2_S11V11_NAME "s11v11"
#define CAN1_AMS_S12_VOLTAGES_1_S12V1_NAME "s12v1"
#define CAN1_AMS_S12_VOLTAGES_1_S12V2_NAME "s12v2"
#define CAN1_AMS_S12_VOLTAGES_1_S12V3_NAME "s12v3"
#define CAN1_AMS_S12_VOLTAGES_1_S12V4_NAME "s12v4"
#define CAN1_AMS_S12_VOLTAGES_1_S12V5_NAME "s12v5"
#define CAN1_AMS_S12_VOLTAGES_1_S12V6_NAME "s12v6"
#define CAN1_AMS_S12_VOLTAGES_2_S12V7_NAME "s12v7"
#define CAN1_AMS_S12_VOLTAGES_2_S12V8_NAME "s12v8"
#define CAN1_AMS_S12_VOLTAGES_2_S12V9_NAME "s12v9"
#define CAN1_AMS_S12_VOLTAGES_2_S12V10_NAME "s12v10"
#define CAN1_AMS_S12_VOLTAGES_2_S12V11_NAME "s12v11"
#define CAN1_IVT_IMPROVED_STATUS_IVT_VOLTAGE_BATTERY_NAME "ivt_voltage_battery"
#define CAN1_IVT_IMPROVED_STATUS_IVT_VOLTAGE_VEHICLE_NAME "ivt_voltage_vehicle"
#define CAN1_IVT_IMPROVED_STATUS_IVT_CURRENT_NAME "ivt_current"
#define CAN1_IVT_IMPROVED_STATUS_TEMP_H_VPLUS_NAME "temp_HVplus"
#define CAN1_IVT_IMPROVED_STATUS_TEMP_H_VMINUS_NAME "temp_HVminus"
#define CAN1_AMS_PARAMETERS_SET_CELL_UNDER_VOLTAGE_TRESHOLD_NAME "cell_under_voltage_treshold"
#define CAN1_AMS_PARAMETERS_SET_CELL_OVER_VOLTAGE_TRESHOLD_NAME "cell_over_voltage_treshold"
#define CAN1_AMS_PARAMETERS_SET_VOLTAGE_TIME_CONSTRAINT_NAME "voltage_time_constraint"
#define CAN1_AMS_PARAMETERS_SET_TEMPERATURE_TIME_CONSTRAINT_NAME "temperature_time_constraint"
#define CAN1_AMS_PARAMETERS_SET_CURRENT_TIME_CONSTRAINT_NAME "current_time_constraint"
#define CAN1_AMS_PARAMETERS_SET_VOLTAGE_DRIVE_LOWER_BOUND_NAME "voltage_drive_lower_bound"
#define CAN1_AMS_PARAMETERS_SET_VOLTAGE_LOWER_BOUND_NAME "voltage_lower_bound"
#define CAN1_AMS_PARAMETERS_SET_START_BALANCING_NAME "start_balancing"
#define CAN1_IVT_U3_ACCUMULATOR_VOLTAGE_NAME "U3_accumulator_voltage"
#define CAN1_IVT_U2_FUSE_VOLTAGE_NAME "U2_fuse_voltage"
#define CAN1_IVT_U1_TS_VOLTAGE_NAME "U1_TS_voltage"
#define CAN1_IVT_I_ACCUMULATOR_CURRENT_NAME "I_accumulator_current"
#define CAN1_IVT_EXTRA_AS_IVT_NAME "As_IVT"
#define CAN1_IVT_EXTRA_T_IVT_TIME_NAME "T_IVT_time"
#define CAN1_IVT_EXTRA_W_IVT_NAME "W_IVT"
#define CAN1_IVT_EXTRA_WH_IVT_NAME "Wh_IVT"
#define CAN1_VEHICLE_STATUS_WHEEL_VELOCITIES_WHEEL_VELOCITY_FL_NAME "wheel_velocity_fl"
#define CAN1_VEHICLE_STATUS_WHEEL_VELOCITIES_WHEEL_VELOCITY_FR_NAME "wheel_velocity_fr"
#define CAN1_VEHICLE_STATUS_WHEEL_VELOCITIES_WHEEL_VELOCITY_RL_NAME "wheel_velocity_rl"
#define CAN1_VEHICLE_STATUS_WHEEL_VELOCITIES_WHEEL_VELOCITY_RR_NAME "wheel_velocity_rr"
#define CAN1_DV_CONTROL_TARGET_TV_DV_FL_SPEEDD_TARGET_NAME "dv_FL_speedd_target"
#define CAN1_DV_CONTROL_TARGET_TV_DV_FR_SPEED_TARGET_NAME "dv_FR_speed_target"
#define CAN1_DV_CONTROL_TARGET_TV_DV_RL_SPEED_TARGET_NAME "dv_RL_speed_target"
#define CAN1_DV_CONTROL_TARGET_TV_DV_RR_SPEED_TARGET_NAME "dv_RR_speed_target"
#define CAN1_DV_CONTROL_TARGET_TV_DV_STEERING_ANGLE_TARGET_TV_NAME "dv_steering_angle_target_TV"
#define CAN1_DV_CONTROL_TARGET_TV_DV_MISSION_STATUS_TV_NAME "dv_mission_status_TV"
#define CAN1_VMU_GPIO_MSGS_TYPE_NAME "msgs_type"
#define CAN1_VMU_GPIO_GPIO_CONFIGURATION_NAME "gpio_configuration"
#define CAN1_VMU_GPIO_IO1_NAME "IO1"
#define CAN1_VMU_GPIO_IO2_NAME "IO2"
#define CAN1_VMU_GPIO_IO3_NAME "IO3"
#define CAN1_VMU_GPIO_IO4_NAME "IO4"
#define CAN1_VMU_GPIO_IO5_NAME "IO5"
#define CAN1_VMU_GPIO_IO6_NAME "IO6"
#define CAN1_DV_INFO_YAW_RATE_NAME "yaw_rate"
#define CAN1_DV_INFO_SPEED_TARGET_NAME "speed_target"
#define CAN1_DV_INFO_LAP_COUNTER_NAME "Lap_counter"
#define CAN1_DV_INFO_CONES_COUNT_ACTUAL_NAME "Cones_count_actual"
#define CAN1_DV_INFO_CONES_COUNT_ALL_NAME "Cones_count_all"
#define CAN1_DV_INFO_ACCELERATION_LONGITUDINAL_NAME "acceleration_longitudinal"
#define CAN1_DV_INFO_ACCELERATION_LATERAL_NAME "acceleration_lateral"
#define CAN1_VEHICLE_STATUS_MOTOR_TORQUES_TORQUE_FL_NAME "torque_fl"
#define CAN1_VEHICLE_STATUS_MOTOR_TORQUES_TORQUE_FR_NAME "torque_fr"
#define CAN1_VEHICLE_STATUS_MOTOR_TORQUES_TORQUE_RL_NAME "torque_rl"
#define CAN1_VEHICLE_STATUS_MOTOR_TORQUES_TORQUE_RR_NAME "torque_rr"
#define CAN1_VEHICLE_STATUS_MOTOR_TEMP_MOTOR_TEMP_FR_NAME "motor_temp_fr"
#define CAN1_VEHICLE_STATUS_MOTOR_TEMP_MOTOR_TEMP_FL_NAME "motor_temp_fl"
#define CAN1_VEHICLE_STATUS_MOTOR_TEMP_MOTOR_TEMP_RR_NAME "motor_temp_rr"
#define CAN1_VEHICLE_STATUS_MOTOR_TEMP_MOTOR_TEMP_RL_NAME "motor_temp_rl"
#define CAN1_VEHICLE_STATUS_INVERTER_TEMP_INVERTER_RR_NAME "inverter_rr"
#define CAN1_VEHICLE_STATUS_INVERTER_TEMP_INVERTER_RL_NAME "inverter_rl"
#define CAN1_VEHICLE_STATUS_INVERTER_TEMP_INVERTER_FR_NAME "inverter_fr"
#define CAN1_VEHICLE_STATUS_INVERTER_TEMP_INVERTER_FL_NAME "inverter_fl"
#define CAN1_VEHICLE_STATUS_INVERTER_TEMP_IGTB_RR_NAME "igtb_rr"
#define CAN1_VEHICLE_STATUS_INVERTER_TEMP_IGTB_RL_NAME "igtb_rl"
#define CAN1_VEHICLE_STATUS_INVERTER_TEMP_IGTB_FR_NAME "igtb_fr"
#define CAN1_VEHICLE_STATUS_INVERTER_TEMP_IGTB_FL_NAME "igtb_fl"
#define CAN1_VEHICLE_STATUS_PEDALS_NORMALIZED_BRAKE_PEDAL_NAME "normalized_brake_pedal"
#define CAN1_VEHICLE_STATUS_PEDALS_NORMALIZED_ACCELERATION_PEDAL_NAME "normalized_acceleration_pedal"
#define CAN1_AMK1_SETPOINTS_1_AMK1_CONTROL_INVERTER_ON_NAME "amk1_control_inverter_on"
#define CAN1_AMK1_SETPOINTS_1_AMK1_CONTROL_DC_ON_NAME "amk1_control_dc_on"
#define CAN1_AMK1_SETPOINTS_1_AMK1_CONTROL_ENABLE_NAME "amk1_control_enable"
#define CAN1_AMK1_SETPOINTS_1_AMK1_CONTROL_ERROR_RESET_NAME "amk1_control_error_reset"
#define CAN1_AMK1_SETPOINTS_1_AMK1_TARGET_VELOCITY_NAME "amk1_target_velocity"
#define CAN1_AMK1_SETPOINTS_1_AMK1_TORQUE_LIMIT_POSITIV_NAME "amk1_torque_limit_positiv"
#define CAN1_AMK1_SETPOINTS_1_AMK1_TORQUE_LIMIT_NEGATIV_NAME "amk1_torque_limit_negativ"
#define CAN1_AMK2_SETPOINTS_1_AMK2_CONTROL_INVERTER_ON_NAME "amk2_control_inverter_on"
#define CAN1_AMK2_SETPOINTS_1_AMK2_CONTROL_DC_ON_NAME "amk2_control_dc_on"
#define CAN1_AMK2_SETPOINTS_1_AMK2_CONTROL_ENABLE_NAME "amk2_control_enable"
#define CAN1_AMK2_SETPOINTS_1_AMK2_CONTROL_ERROR_RESET_NAME "amk2_control_error_reset"
#define CAN1_AMK2_SETPOINTS_1_AMK2_TARGET_VELOCITY_NAME "amk2_target_velocity"
#define CAN1_AMK2_SETPOINTS_1_AMK2_TORQUE_LIMIT_POSITIV_NAME "amk2_torque_limit_positiv"
#define CAN1_AMK2_SETPOINTS_1_AMK2_TORQUE_LIMIT_NEGATIV_NAME "amk2_torque_limit_negativ"
#define CAN1_AMK3_SETPOINTS_1_AMK3_CONTROL_INVERTER_ON_NAME "amk3_control_inverter_on"
#define CAN1_AMK3_SETPOINTS_1_AMK3_CONTROL_DC_ON_NAME "amk3_control_dc_on"
#define CAN1_AMK3_SETPOINTS_1_AMK3_CONTROL_ENABLE_NAME "amk3_control_enable"
#define CAN1_AMK3_SETPOINTS_1_AMK3_CONTROL_ERROR_RESET_NAME "amk3_control_error_reset"
#define CAN1_AMK3_SETPOINTS_1_AMK3_TARGET_VELOCITY_NAME "amk3_target_velocity"
#define CAN1_AMK3_SETPOINTS_1_AMK3_TORQUE_LIMIT_POSITIV_NAME "amk3_torque_limit_positiv"
#define CAN1_AMK3_SETPOINTS_1_AMK3_TORQUE_LIMIT_NEGATIV_NAME "amk3_torque_limit_negativ"
#define CAN1_AMK4_SETPOINTS_1_AMK4_CONTROL_INVERTER_ON_NAME "amk4_control_inverter_on"
#define CAN1_AMK4_SETPOINTS_1_AMK4_CONTROL_DC_ON_NAME "amk4_control_dc_on"
#define CAN1_AMK4_SETPOINTS_1_AMK4_CONTROL_ENABLE_NAME "amk4_control_enable"
#define CAN1_AMK4_SETPOINTS_1_AMK4_CONTROL_ERROR_RESET_NAME "amk4_control_error_reset"
#define CAN1_AMK4_SETPOINTS_1_AMK4_TARGET_VELOCITY_NAME "amk4_target_velocity"
#define CAN1_AMK4_SETPOINTS_1_AMK4_TORQUE_LIMIT_POSITIV_NAME "amk4_torque_limit_positiv"
#define CAN1_AMK4_SETPOINTS_1_AMK4_TORQUE_LIMIT_NEGATIV_NAME "amk4_torque_limit_negativ"
#define CAN1_SBG_ECAN_MSG_TRACK_SLIP_CURVATUR_ANGLE_TRACK_NAME "ANGLE_TRACK"
#define CAN1_SBG_ECAN_MSG_TRACK_SLIP_CURVATUR_ANGLE_SLIP_NAME "ANGLE_SLIP"
#define CAN1_SBG_ECAN_MSG_TRACK_SLIP_CURVATUR_CURVATURE_RADIUS_NAME "CURVATURE_RADIUS"
#define CAN1_SLIP_SENSOR_SPEED_Y_NAME "speedY"
#define CAN1_SLIP_SENSOR_SPEED_X_NAME "SpeedX"
#define CAN1_JON_SLIP_X_NAME "x"
#define CAN1_JON_SLIP_Y_NAME "y"
#define CAN1_VEHICLE_STATUS_ACCUMULATOR_SOC_SOC_CC_NAME "SOC_CC"
#define CAN1_VEHICLE_STATUS_ACCUMULATOR_SOC_SOC_KALMAN_NAME "SOC_Kalman"

/**
 * Signals in message ams_status_1.
 *
 * Used for DBU hardware IO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_status_1_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charging_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t air1_closed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t air2_closed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sc_closed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pre_charge_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ams_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_error;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state_of_charge;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t min_cell_voltage;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t max_cell_voltage;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t min_cell_temperature;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t max_cell_temperature;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan_speed;

    /**
     * show is blanacing is activated or not
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balance_status;
};

/**
 * Signals in message ams_state.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_state_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t state;
};

/**
 * Signals in message ams_error.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_error_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t reset_cause;
};

/**
 * Signals in message dv_driving_dynamics_1.
 *
 * Period time:100ms, Required by FSG.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_driving_dynamics_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_target;

    /**
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steering_angle_actual;

    /**
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steering_angle_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydr_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydr_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_moment_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_moment_target;
};

/**
 * Signals in message dv_driving_dynamics_2.
 *
 * Period time:100ms, Required by FSG.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_driving_dynamics_2_t {
    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t acceleration_longitudinal;

    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int16_t acceleration_lateral;

    /**
     * Range: -
     * Scale: 0.0078125
     * Offset: 0
     */
    int16_t yaw_rate;
};

/**
 * Signals in message dv_system_status.
 *
 * Period time:100ms, Required by FSG.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_system_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ami_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t service_brake_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cones_count_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t cones_count_all;
};

/**
 * Signals in message mcu_set_ecu_indicator_points.
 *
 * Period time=50ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_mcu_set_ecu_indicator_points_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_light;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t r2d_sound;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_yellow_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_yellow_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_yellow_rear;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_blue_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_blue_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t assi_blue_rear;
};

/**
 * Signals in message mcu_set_dbu_indicator_points.
 *
 * Period time =500ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_mcu_set_dbu_indicator_points_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_indicator_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t r2d_indicator_on;
};

/**
 * Signals in message res_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t e_stop;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t e_stop_redundancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t radio_quality;

    /**
     * pre-alarm radio communication interruption (200 ms in advance to shutdown)
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t radio_state;
};

/**
 * Signals in message res_initialization.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_initialization_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t res_init;
};

/**
 * Signals in message res_nmt_node_control.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_nmt_node_control_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t requested_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t node_id;
};

/**
 * Signals in message swu_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_swu_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_6;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_switch_1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_switch_2;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_switch_3;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_switch_4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_1_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_2_button;

    /**
     * Range: -128..127 (-128..127 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t encoder_1;

    /**
     * Range: -128..127 (-128..127 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t encoder_2;
};

/**
 * Signals in message dbu_status_1.
 *
 * Period time=100ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dbu_status_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t activate_ts_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ready_to_drive_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t selected_mission;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t dbu_temperature;
};

/**
 * Signals in message lv_power_signal.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_lv_power_signal_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_on;
};

/**
 * Signals in message lv_bms_data_a.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_lv_bms_data_a_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_multiplexor;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.007843
     * Offset: 2.5
     */
    uint8_t voltage_cell_1;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_1;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t therm1;

    /**
     * Range: 0..4095 (0..20 A)
     * Scale: 0.004884
     * Offset: 0
     */
    uint16_t current;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.007843
     * Offset: 2.5
     */
    uint8_t voltage_cell_2;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_2;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t therm2;

    /**
     * Range: 0..16777291 (0..356400 As)
     * Scale: 0.021243
     * Offset: 0
     */
    uint32_t current_count;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.007843
     * Offset: 2.5
     */
    uint8_t voltage_cell_3;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.007843
     * Offset: 2.5
     */
    uint8_t voltage_cell_4;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_4;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t therm3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.007843
     * Offset: 2.5
     */
    uint8_t voltage_cell_5;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_5;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t therm4;

    /**
     * Range: 0..16777273 (0..1532520 Ws)
     * Scale: 0.091345
     * Offset: 0
     */
    uint32_t energy_count;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.007843
     * Offset: 2.5
     */
    uint8_t voltage_cell_6;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_6;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t therm5;
};

/**
 * Signals in message lv_bms_status_a.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_lv_bms_status_a_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_bms_error;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc;

    /**
     * Range: 0..4095 (0..20 A)
     * Scale: 0.004884
     * Offset: 0
     */
    uint16_t current;

    /**
     * Range: 0..4095 (15..30 V)
     * Scale: 0.003663
     * Offset: 15
     */
    uint16_t voltage;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t temperature;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t not_battery_output_enable;
};

/**
 * Signals in message ams_temperatures.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_temperatures_t {
    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t pre_charge_resistor_temperature;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t fuse_resistor_temperature;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t aux_1_temperature;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t aux_2_temperature;
};

/**
 * Signals in message ams_cell_voltages.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_cell_voltages_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t voltage_multiplexor;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s6;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s6;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s11;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s11;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s12;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s12;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s6;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s6;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s11;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s11;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s12;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s12;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s6;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s6;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s11;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s11;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s12;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s12;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s6;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s6;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s11;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s11;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s12;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s12;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s6;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s11;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s11;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s12;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s6;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s11;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s12;
};

/**
 * Signals in message ams_cell_temperatures.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_cell_temperatures_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t temperature_multiplexor;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s1;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s2;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s3;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s4;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s5;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s6;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s7;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s8;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s9;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s10;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s11;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s12;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s1;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s2;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s3;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s4;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s5;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s6;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s7;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s8;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s9;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s10;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s11;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s12;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s1;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s2;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s3;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s4;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s5;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s6;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s7;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s8;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s9;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s10;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s11;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s12;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s1;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s2;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s3;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s4;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s5;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s6;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s7;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s8;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s9;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s10;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s11;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s12;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s1;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s2;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s3;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s4;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s5;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s6;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s7;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s8;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s9;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s10;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s11;

    /**
     * Range: 0..4095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s12;
};

/**
 * Signals in message ecu_status.
 *
 * Period time:100ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ecu_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_not_off;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t rst_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sidepanel_activate_ts_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_off;
};

/**
 * Signals in message ebs_status.
 *
 * Period time:100ms, Required by FSG.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ebs_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_state_machine;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_status;

    /**
     * Range: -
     * Scale: 0.05
     * Offset: 0
     */
    uint8_t ebs_pressure_1;

    /**
     * Range: -
     * Scale: 0.05
     * Offset: 0
     */
    uint8_t ebs_pressure_2;

    /**
     * Range: -
     * Scale: 0.2
     * Offset: 0
     */
    uint16_t brake_pressure_front;

    /**
     * Range: -
     * Scale: 0.2
     * Offset: 0
     */
    uint16_t brake_pressure_rear;
};

/**
 * Signals in message fb_pedals.
 *
 * Period Time=20ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fb_pedals_t {
    /**
     * adc reading
     *
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps_1;

    /**
     * adc reading
     *
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps_2;

    /**
     * adc reading
     *
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t bpps_1;

    /**
     * adc reading
     *
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t bpps_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bpps_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_error;
};

/**
 * Signals in message mcu_set_ccu_cooling_points.
 *
 * Period time=200ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_mcu_set_ccu_cooling_points_t {
    /**
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t fan1_speed;

    /**
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t fan2_speed;

    /**
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t fan3_speed;

    /**
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t pump1_speed;

    /**
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t pump2_speed;

    /**
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t pump3_speed;
};

/**
 * Signals in message ccu_status_1.
 *
 * Period time: 100ms

 *
 * All signal values are as on the CAN bus.
 */
struct can1_ccu_status_1_t {
    /**
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mux_id;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan1_temperature;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan2_temperature;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan3_temperature;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fron_pump_temperature;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rear_pump_temperature;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_pump_temperature;
};

/**
 * Signals in message ccu_status_2.
 *
 * Period time: 100ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ccu_status_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t digital_input;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t discharge_relay_open;

    /**
     * Range: 0..200 (-10..190 C)
     * Scale: 1
     * Offset: -10
     */
    int16_t discharge_resistor_temperature;

    /**
     * Range: 0..200 (-10..190 C)
     * Scale: 1
     * Offset: -10
     */
    int16_t extra_temperature;
};

/**
 * Signals in message vehicle_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vehicle_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t car_state;

    /**
     * Range: 0..200 (0..200 kph)
     * Scale: 1
     * Offset: 0
     */
    uint8_t car_velocity;

    /**
     * Range: 0..100 (0..100 kW)
     * Scale: 1
     * Offset: 0
     */
    uint16_t car_power;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t car_regen_level;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ready_to_drive;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t torque_vectoring_active;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t traction_control_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t abs_on;
};

/**
 * Signals in message fault.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fault_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t unit_id;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_discrepancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sc_open;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_off_watchdog_triggered;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bpps_discrepancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pressure_discrepancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_angle_discrepancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_out_of_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bpps_out_of_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pressure_out_of_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_angle_out_of_range;
};

/**
 * Signals in message steering.
 *
 * Period time=20ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_steering_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t steering_angle_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t steering_angle_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t steering_angle;

    /**
     * Range: -1000..1000 (-1000..1000 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t steering_angle_normalized;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_angle_error;
};

/**
 * Signals in message dbu_status_2.
 *
 * Used for DBU software IO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dbu_status_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t screen_id;
};

/**
 * Signals in message dv_control_target.
 *
 * Normal DV control without TV

 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_control_target_t {
    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t dv_speed_target;

    /**
     * Range: -9000..9000 (-90..90 degree)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t dv_steering_angle_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t dv_brake_hydralic_target;

    /**
     * Range: -10000..10000 (-100..100 %)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t dv_motor_moment_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t dv_mission_status;
};

/**
 * Signals in message vehicle_status_wheel_speed.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vehicle_status_wheel_speed_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t wheel_speed_fl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t wheel_speed_fr;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t wheel_speed_rl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t wheel_speed_rr;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_HDT.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_hdt_t {
    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t true_heading;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t true_heading_acc;

    /**
     * Range: -32768..32767 (-327.68..327.67 )
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pitch_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_HDT_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_hdt_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t status;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_POS_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_pos_acc_t {
    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t latitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t longitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t altitude_acc;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t base_station_id;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_POS_ALT.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_pos_alt_t {
    /**
     * Range: -2147480000..2147480000 (-2147480..2147480 m)
     * Scale: 0.001
     * Offset: 0
     */
    int32_t altitude;

    /**
     * Range: -32768..32767 (-163.84..163.835 m)
     * Scale: 0.005
     * Offset: 0
     */
    int16_t undulation;

    /**
     * Range: 0..255 (48..303 -)
     * Scale: 1
     * Offset: 48
     */
    uint8_t num_sv;

    /**
     * Range: 0..255 (7..262 s)
     * Scale: 1
     * Offset: 7
     */
    uint8_t diff_corr_age;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_POS.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_pos_t {
    /**
     * Range: -21474800000..21474800000 (-2147.48..2147.48 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t latitude;

    /**
     * Range: -21474800000..21474800000 (-2147.48..2147.48 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t longitude;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_POS_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_pos_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..2704 (0..2704 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t status;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_VEL_COURSE.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_vel_course_t {
    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t course;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t course_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_VEL_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_vel_acc_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_d;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_vel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_d;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS2_VEL_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps2_vel_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..2704 (0..2704 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t status;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_HDT.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_hdt_t {
    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t true_heading;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t true_heading_acc;

    /**
     * Range: -32768..32767 (-327.68..327.67 )
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pitch_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_HDT_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_hdt_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t status;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_POS_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_pos_acc_t {
    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t latitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t longitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t altitude_acc;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t base_station_id;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_POS_ALT.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_pos_alt_t {
    /**
     * Range: -2147480000..2147480000 (-2147480..2147480 m)
     * Scale: 0.001
     * Offset: 0
     */
    int32_t altitude;

    /**
     * Range: -32768..32767 (-163.84..163.835 m)
     * Scale: 0.005
     * Offset: 0
     */
    int16_t undulation;

    /**
     * Range: 0..255 (48..303 -)
     * Scale: 1
     * Offset: 48
     */
    uint8_t num_sv;

    /**
     * Range: 0..255 (7..262 s)
     * Scale: 1
     * Offset: 7
     */
    uint8_t diff_corr_age;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_POS.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_pos_t {
    /**
     * Range: -21474800000..21474800000 (-2147.48..2147.48 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t latitude;

    /**
     * Range: -21474800000..21474800000 (-2147.48..2147.48 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t longitude;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_POS_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_pos_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..2704 (0..2704 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t status;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_VEL_COURSE.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_vel_course_t {
    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t course;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t course_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_VEL_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_vel_acc_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_d;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_vel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_d;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_VEL_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_vel_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..2704 (0..2704 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t status;
};

/**
 * Signals in message SBG_ECAN_MSG_ODO_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_odo_vel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity;
};

/**
 * Signals in message SBG_ECAN_MSG_ODO_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_odo_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t odo_status;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_VEL_BODY.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_vel_body_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_z;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_VEL_NED_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_vel_ned_acc_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_d;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_vel_ned_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_d;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_POS_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_pos_acc_t {
    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t latitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t longitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t altitude_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_POS.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_pos_t {
    /**
     * Range: -21474800000..21474800000 (-2147.48..2147.48 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t latitude;

    /**
     * Range: -21474800000..21474800000 (-2147.48..2147.48 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t longitude;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_ORIENTATION_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_orientation_acc_t {
    /**
     * Range: 0..65535 (0..6.5535 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t roll_acc;

    /**
     * Range: 0..65535 (0..6.5535 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t pitch_acc;

    /**
     * Range: 0..65535 (0..6.5535 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t yaw_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_EULER.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_euler_t {
    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t roll;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t yaw;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_QUAT.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_quat_t {
    /**
     * Range: -33286..33285 (-1.01581..1.01578 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q0;

    /**
     * Range: -33286..33285 (-1.01581..1.01578 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q1;

    /**
     * Range: -33286..33285 (-1.01581..1.01578 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q2;

    /**
     * Range: -33286..33285 (-1.01581..1.01578 -)
     * Scale: 3.0517578125e-05
     * Offset: 0
     */
    int16_t q3;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_DELTA_ANGLE.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_imu_delta_angle_t {
    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t delta_angle_x;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t delta_angle_y;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t delta_angle_z;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_DELTA_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_imu_delta_vel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t delta_vel_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t delta_vel_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t delta_vel_z;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_GYRO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_imu_gyro_t {
    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_x;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_y;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_z;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_ACCEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_imu_accel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_z;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_imu_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t status;

    /**
     * Range: -32768..32767 (-327.68..327.67 C)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t temperature;
};

/**
 * Signals in message SBG_ECAN_MSG_UTC_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_utc_1_t {
    /**
     * Range: 0..255 (2000..2255 year)
     * Scale: 1
     * Offset: 2000
     */
    uint8_t year;

    /**
     * Range: 0..255 (0..255 month)
     * Scale: 1
     * Offset: 0
     */
    uint8_t month;

    /**
     * Range: 0..255 (0..255 d)
     * Scale: 1
     * Offset: 0
     */
    uint8_t day;

    /**
     * Range: 0..255 (0..255 h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hour;

    /**
     * Range: 0..255 (0..255 min)
     * Scale: 1
     * Offset: 0
     */
    uint8_t min;

    /**
     * Range: 0..255 (0..255 s)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sec;

    /**
     * Range: 0..65535 (0..6553500 us)
     * Scale: 100
     * Offset: 0
     */
    uint16_t micro_sec;
};

/**
 * Signals in message SBG_ECAN_MSG_UTC_0.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_utc_0_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..2704 (0..2704 ms)
     * Scale: 1
     * Offset: 0
     */
    uint32_t gps_tow;
};

/**
 * Signals in message FS_Datalogger_Reserved_6.
 *
 * Specified by FSG document, not sure of the purpose. 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_reserved_6_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message FS_Datalogger_Reserved_5.
 *
 * Specified by FSG document, not sure of the purpose. 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_reserved_5_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message FS_Datalogger_Reserved_4.
 *
 * Specified by FSG document, not sure of the purpose. 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_reserved_4_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message FS_Datalogger_Reserved_3.
 *
 * Specified by FSG document, not sure of the purpose. 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_reserved_3_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message FS_Datalogger_Reserved_2.
 *
 * Specified by FSG document, not sure of the purpose. 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_reserved_2_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message FS_Datalogger_Reserved_1.
 *
 * Specified by FSG document, not sure of the purpose. 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_reserved_1_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message FS_Datalogger_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fs_datalogger_status_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_cnt;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t status_ready;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t status_logging;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t status_triggered_voltage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t status_triggered_current;

    /**
     * Range: 0..65535 (0..1048560 mV)
     * Scale: 16
     * Offset: 0
     */
    uint16_t voltage;

    /**
     * Range: 0..65535 (0..4194240 mA)
     * Scale: 64
     * Offset: 0
     */
    uint16_t current;
};

/**
 * Signals in message vesc_status_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vesc_status_2_t {
    /**
     * Range: -
     * Scale: 0.0001
     * Offset: 0
     */
    int32_t amp_hours;

    /**
     * Range: -
     * Scale: 0.0001
     * Offset: 0
     */
    int32_t amp_hours_chg;
};

/**
 * Signals in message vesc_status_4.
 *
 * Temp Fet, Temp Motor, Current In, PID position
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vesc_status_4_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t temp_fet;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t temp_motor;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t current_in;

    /**
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    int16_t pid_pos;
};

/**
 * Signals in message vesc_status_5.
 *
 * Tachometer, Voltage In
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vesc_status_5_t {
    /**
     * Range: -
     * Scale: 0.6
     * Offset: 0
     */
    int32_t tachometer;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t volts_in;
};

/**
 * Signals in message vesc_status_6.
 *
 * ADC1, ADC2, ADC3, PPM
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vesc_status_6_t {
    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t adc1;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t adc2;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t adc3;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t ppm;
};

/**
 * Signals in message vesc_set_duty.
 *
 * Period Time=200ms, Set duty cycle for DV motor
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vesc_set_duty_t {
    /**
     * Duty Cycle
     *
     * Range: -100000..100000 (-1..1 %/100)
     * Scale: 1e-05
     * Offset: 0
     */
    int32_t set_duty;
};

/**
 * Signals in message vesc_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vesc_status_t {
    /**
     * ERPM
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t erpm;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t current;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t duty_cycle;
};

/**
 * Signals in message ams_s1_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s1_voltages_1_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v6;
};

/**
 * Signals in message ams_s1_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s1_voltages_2_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s1v11;
};

/**
 * Signals in message ams_s2_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s2_voltages_1_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v6;
};

/**
 * Signals in message ams_s2_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s2_voltages_2_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s2v11;
};

/**
 * Signals in message ams_s3_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s3_voltages_1_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v6;
};

/**
 * Signals in message ams_s3_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s3_voltages_2_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s3v11;
};

/**
 * Signals in message ams_s4_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s4_voltages_1_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v6;
};

/**
 * Signals in message ams_s4_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s4_voltages_2_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s4v11;
};

/**
 * Signals in message ams_s5_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s5_voltages_1_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v6;
};

/**
 * Signals in message ams_s5_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s5_voltages_2_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s5v11;
};

/**
 * Signals in message ams_s6_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s6_voltages_1_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v6;
};

/**
 * Signals in message ams_s6_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s6_voltages_2_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s6v11;
};

/**
 * Signals in message ams_s7_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s7_voltages_1_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v6;
};

/**
 * Signals in message ams_s7_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s7_voltages_2_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s7v11;
};

/**
 * Signals in message ams_s8_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s8_voltages_1_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v6;
};

/**
 * Signals in message ams_s8_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s8_voltages_2_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s8v11;
};

/**
 * Signals in message ams_s9_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s9_voltages_1_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v6;
};

/**
 * Signals in message ams_s9_voltages_2.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s9_voltages_2_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s9v11;
};

/**
 * Signals in message ams_s10_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s10_voltages_1_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v6;
};

/**
 * Signals in message ams_s10_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s10_voltages_2_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s10v11;
};

/**
 * Signals in message ams_s11_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s11_voltages_1_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v6;
};

/**
 * Signals in message ams_s11_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s11_voltages_2_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s11v11;
};

/**
 * Signals in message ams_s12_voltages_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s12_voltages_1_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v1;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v2;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v3;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v4;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v5;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v6;
};

/**
 * Signals in message ams_s12_voltages_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_s12_voltages_2_t {
    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v7;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v8;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v9;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v10;

    /**
     * Range: 0..255 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t s12v11;
};

/**
 * Signals in message ivt_improved_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ivt_improved_status_t {
    /**
     * Voltage measurement on battery side
     *
     * Range: 0..600 (0..600 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ivt_voltage_battery;

    /**
     * Voltage measurement on vehicle side
     *
     * Range: 0..600 (0..600 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ivt_voltage_vehicle;

    /**
     * Current measurement
     *
     * Range: -50..200 (-50..200 A)
     * Scale: 1
     * Offset: 0
     */
    int16_t ivt_current;

    /**
     * Temperature Measurement on the HV+ side of board
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp_h_vplus;

    /**
     * Temperature Measurement on HV- side of battery
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t temp_h_vminus;
};

/**
 * Signals in message res_recieve_PDO.
 *
 * From competition handbook
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_recieve_pdo_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message res_transmit_SDO.
 *
 * From competition handbook
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_transmit_sdo_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message res_recieve_SDO.
 *
 * From competition handbook
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_recieve_sdo_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message res_transmit_LSS.
 *
 * From competition handbook
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_transmit_lss_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message res_recieve_LSS.
 *
 * From competition handbook
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_recieve_lss_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message AMS_parameters_set.
 *
 * Send this message to the AMS to update it's parameters (Only during run, restarting AMS resets these parameters to default in code)
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_parameters_set_t {
    /**
     * Set lowest cell voltage. WARNING don't drive with a limit lower than 2.8V
     *
     * Range: 25..40 (2.5..4 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t cell_under_voltage_treshold;

    /**
     * Set highest cell voltage. WARNING don't drive with a max voltage above 4.2V.
     *
     * Range: 30..44 (3..4.4 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t cell_over_voltage_treshold;

    /**
     * Set time cell is allowed to have voltage error before AMS error triggers
     *
     * Range: 0..50 (0..5 s)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t voltage_time_constraint;

    /**
     * Set time cell is allowed to have temperature error before AMS error triggers
     *
     * Range: 0..50 (0..5 s)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t temperature_time_constraint;

    /**
     * Set time cell is allowed to have current error before AMS error triggers
     *
     * Range: 0..50 (0..5 s)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t current_time_constraint;

    /**
     * Set lowest accumulator voltage required to enter drive state
     *
     * Range: 0..5300 (0..530 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t voltage_drive_lower_bound;

    /**
     * Set accumulator lowest allowed voltage
     *
     * Range: 0..5300 (0..530 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t voltage_lower_bound;

    /**
     * enable/disable balancing
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_balancing;
};

/**
 * Signals in message IVT.
 *
 * Forwarded IVT messages, sent from AMS
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ivt_t {
    /**
     * Range: 0..26500 (0..530 V)
     * Scale: 0.02
     * Offset: 0
     */
    int16_t u3_accumulator_voltage;

    /**
     * Range: 0..26500 (0..530 V)
     * Scale: 0.02
     * Offset: 0
     */
    int16_t u2_fuse_voltage;

    /**
     * Range: 0..26500 (0..530 V)
     * Scale: 0.02
     * Offset: 0
     */
    int16_t u1_ts_voltage;

    /**
     * Range: -8000..20000 (-80..200 A)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t i_accumulator_current;
};

/**
 * Signals in message IVT_extra.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ivt_extra_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t as_ivt;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_ivt_time;

    /**
     * Range: -10000..18000 (-50..90 kW)
     * Scale: 0.005
     * Offset: 0
     */
    int16_t w_ivt;

    /**
     * Range: -
     * Scale: 0.05
     * Offset: 0
     */
    int16_t wh_ivt;
};

/**
 * Signals in message vehicle_status_wheel_velocities.
 *
 * Effective velocity of wheels. For IMU EKF

 *
 * All signal values are as on the CAN bus.
 */
struct can1_vehicle_status_wheel_velocities_t {
    /**
     * Range: -33333..33333 (-100..100 m/s)
     * Scale: 0.003
     * Offset: 0
     */
    int16_t wheel_velocity_fl;

    /**
     * Range: -33333..33333 (-100..100 m/s)
     * Scale: 0.003
     * Offset: 0
     */
    int16_t wheel_velocity_fr;

    /**
     * Range: -33333..33333 (-100..100 m/s)
     * Scale: 0.003
     * Offset: 0
     */
    int16_t wheel_velocity_rl;

    /**
     * Range: -33333..33333 (-100..100 m/s)
     * Scale: 0.003
     * Offset: 0
     */
    int16_t wheel_velocity_rr;
};

/**
 * Signals in message dv_control_target_TV.
 *
 * dv control for Torque Vectoring implementation

 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_control_target_tv_t {
    /**
     * Range: 0..3400 (0..34 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t dv_fl_speedd_target;

    /**
     * Range: 0..3400 (0..34 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t dv_fr_speed_target;

    /**
     * Range: 0..3400 (0..34 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t dv_rl_speed_target;

    /**
     * Range: 0..3400 (0..34 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t dv_rr_speed_target;

    /**
     * Range: -560..560 (-28..28 deg)
     * Scale: 0.05
     * Offset: 0
     */
    int16_t dv_steering_angle_target_tv;

    /**
     * 
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t dv_mission_status_tv;
};

/**
 * Signals in message vmu_gpio.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vmu_gpio_t {
    /**
     * Message type
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t msgs_type;

    /**
     * GPIO is input or output configuration. 0 = input, 1 = output
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t gpio_configuration;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t io1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t io2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t io3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t io4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t io5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t io6;
};

/**
 * Signals in message res_sync.
 *
 * Reserver from FSG handbook

 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_sync_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message res_emergency.
 *
 * Reserved from FSG handbook
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_emergency_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message res_timestamp.
 *
 * Reserved from FSG handbook

 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_timestamp_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message dv_info.
 *
 * to be used in dv_system_status due to FSG handbook

 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_info_t {
    /**
     * Range: -
     * Scale: 0.0078
     * Offset: 0
     */
    int16_t yaw_rate;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cones_count_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cones_count_all;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t acceleration_longitudinal;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t acceleration_lateral;
};

/**
 * Signals in message vehicle_status_motor_torques.
 *
 * Period time:200ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vehicle_status_motor_torques_t {
    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_fl;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_fr;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_rl;

    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int16_t torque_rr;
};

/**
 * Signals in message vehicle_status_motor_temp.
 *
 * Period time:500ms, Forwarded inverter messages sent form dSPACE
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vehicle_status_motor_temp_t {
    /**
     * Range: -
     * Scale: 0.3
     * Offset: 0
     */
    int16_t motor_temp_fr;

    /**
     * Range: -
     * Scale: 0.3
     * Offset: 0
     */
    int16_t motor_temp_fl;

    /**
     * Range: -
     * Scale: 0.3
     * Offset: 0
     */
    int16_t motor_temp_rr;

    /**
     * Range: -
     * Scale: 0.3
     * Offset: 0
     */
    int16_t motor_temp_rl;
};

/**
 * Signals in message vehicle_status_inverter_temp.
 *
 * Period time:500ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vehicle_status_inverter_temp_t {
    /**
     * Range: -
     * Scale: 0.3
     * Offset: 0
     */
    uint8_t inverter_rr;

    /**
     * Range: -
     * Scale: 0.3
     * Offset: 0
     */
    uint8_t inverter_rl;

    /**
     * Range: -
     * Scale: 0.3
     * Offset: 0
     */
    uint8_t inverter_fr;

    /**
     * Range: -
     * Scale: 0.3
     * Offset: 0
     */
    uint8_t inverter_fl;

    /**
     * Range: -
     * Scale: 0.3
     * Offset: 0
     */
    uint8_t igtb_rr;

    /**
     * Range: -
     * Scale: 0.3
     * Offset: 0
     */
    uint8_t igtb_rl;

    /**
     * Range: -
     * Scale: 0.3
     * Offset: 0
     */
    uint8_t igtb_fr;

    /**
     * Range: -
     * Scale: 0.3
     * Offset: 0
     */
    uint8_t igtb_fl;
};

/**
 * Signals in message vehicle_status_pedals.
 *
 * Period time:200ms

 *
 * All signal values are as on the CAN bus.
 */
struct can1_vehicle_status_pedals_t {
    /**
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t normalized_brake_pedal;

    /**
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t normalized_acceleration_pedal;
};

/**
 * Signals in message amk1_setpoints_1.
 *
 * Period time 20ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_amk1_setpoints_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_control_inverter_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_control_dc_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_control_enable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_control_error_reset;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk1_target_velocity;

    /**
     * Percentage of 9.8Nm nominal torque
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk1_torque_limit_positiv;

    /**
     * Percentage of 9.8Nm nominal torque
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk1_torque_limit_negativ;
};

/**
 * Signals in message amk2_setpoints_1.
 *
 * Period time 20ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_amk2_setpoints_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_control_inverter_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_control_dc_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_control_enable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_control_error_reset;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk2_target_velocity;

    /**
     * Percentage of 9.8Nm nominal torque
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk2_torque_limit_positiv;

    /**
     * Percentage of 9.8Nm nominal torque
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk2_torque_limit_negativ;
};

/**
 * Signals in message amk3_setpoints_1.
 *
 * Period time 20ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_amk3_setpoints_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk3_control_inverter_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk3_control_dc_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk3_control_enable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk3_control_error_reset;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk3_target_velocity;

    /**
     * Percentage of 9.8Nm nominal torque
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk3_torque_limit_positiv;

    /**
     * Percentage of 9.8Nm nominal torque
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk3_torque_limit_negativ;
};

/**
 * Signals in message amk4_setpoints_1.
 *
 * Period time 20ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_amk4_setpoints_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk4_control_inverter_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk4_control_dc_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk4_control_enable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk4_control_error_reset;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk4_target_velocity;

    /**
     * Percentage of 9.8Nm nominal torque
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk4_torque_limit_positiv;

    /**
     * Percentage of 9.8Nm nominal torque
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk4_torque_limit_negativ;
};

/**
 * Signals in message SBG_ECAN_MSG_TRACK_SLIP_CURVATUR.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_track_slip_curvatur_t {
    /**
     * Range: -
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t angle_track;

    /**
     * Range: -
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t angle_slip;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t curvature_radius;
};

/**
 * Signals in message Slip_sensor.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_slip_sensor_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t speed_y;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t speed_x;
};

/**
 * Signals in message jon_slip.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_jon_slip_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t x;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t y;
};

/**
 * Signals in message vehicle_status_accumulator_soc.
 *
 * Period time 100ms
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vehicle_status_accumulator_soc_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t soc_cc;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t soc_kalman;
};

/**
 * Pack message ams_status_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_status_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_status_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_status_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_status_1_unpack(
    struct can1_ams_status_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_status_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_status_1_init(struct can1_ams_status_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_charging_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_charging_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_charging_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_air1_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_air1_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_air1_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_air2_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_air2_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_air2_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_sc_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_sc_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_sc_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_pre_charge_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_pre_charge_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_pre_charge_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_ams_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_ams_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_ams_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_imd_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_imd_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_imd_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_state_of_charge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_state_of_charge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_state_of_charge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_min_cell_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_min_cell_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_min_cell_voltage_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_max_cell_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_max_cell_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_max_cell_voltage_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_status_1_min_cell_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_min_cell_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_min_cell_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_status_1_max_cell_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_max_cell_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_max_cell_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_fan_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_fan_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_fan_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_balance_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_balance_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_balance_status_is_in_range(uint8_t value);

/**
 * Pack message ams_state.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_state_pack(
    uint8_t *dst_p,
    const struct can1_ams_state_t *src_p,
    size_t size);

/**
 * Unpack message ams_state.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_state_unpack(
    struct can1_ams_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_state.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_state_init(struct can1_ams_state_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t can1_ams_state_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_state_state_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_state_state_is_in_range(uint64_t value);

/**
 * Pack message ams_error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_error_pack(
    uint8_t *dst_p,
    const struct can1_ams_error_t *src_p,
    size_t size);

/**
 * Unpack message ams_error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_error_unpack(
    struct can1_ams_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_error.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_error_init(struct can1_ams_error_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_ams_error_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_error_error_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_error_error_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_ams_error_reset_cause_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_error_reset_cause_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_error_reset_cause_is_in_range(uint32_t value);

/**
 * Pack message dv_driving_dynamics_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_driving_dynamics_1_pack(
    uint8_t *dst_p,
    const struct can1_dv_driving_dynamics_1_t *src_p,
    size_t size);

/**
 * Unpack message dv_driving_dynamics_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_driving_dynamics_1_unpack(
    struct can1_dv_driving_dynamics_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from dv_driving_dynamics_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_dv_driving_dynamics_1_init(struct can1_dv_driving_dynamics_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_driving_dynamics_1_speed_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_speed_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_speed_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_driving_dynamics_1_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_speed_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_speed_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_1_steering_angle_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_steering_angle_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_steering_angle_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_1_steering_angle_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_steering_angle_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_steering_angle_target_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_driving_dynamics_1_brake_hydr_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_brake_hydr_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_brake_hydr_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_driving_dynamics_1_brake_hydr_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_brake_hydr_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_brake_hydr_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_1_motor_moment_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_motor_moment_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_motor_moment_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_1_motor_moment_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_motor_moment_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_motor_moment_target_is_in_range(int8_t value);

/**
 * Pack message dv_driving_dynamics_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_driving_dynamics_2_pack(
    uint8_t *dst_p,
    const struct can1_dv_driving_dynamics_2_t *src_p,
    size_t size);

/**
 * Unpack message dv_driving_dynamics_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_driving_dynamics_2_unpack(
    struct can1_dv_driving_dynamics_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from dv_driving_dynamics_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_dv_driving_dynamics_2_init(struct can1_dv_driving_dynamics_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dv_driving_dynamics_2_acceleration_longitudinal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_2_acceleration_longitudinal_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_2_acceleration_longitudinal_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dv_driving_dynamics_2_acceleration_lateral_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_2_acceleration_lateral_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_2_acceleration_lateral_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dv_driving_dynamics_2_yaw_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_2_yaw_rate_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_2_yaw_rate_is_in_range(int16_t value);

/**
 * Pack message dv_system_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_system_status_pack(
    uint8_t *dst_p,
    const struct can1_dv_system_status_t *src_p,
    size_t size);

/**
 * Unpack message dv_system_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_system_status_unpack(
    struct can1_dv_system_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from dv_system_status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_dv_system_status_init(struct can1_dv_system_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_as_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_as_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_as_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_ebs_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_ebs_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_ebs_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_ami_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_ami_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_ami_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_steering_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_steering_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_steering_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_service_brake_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_service_brake_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_service_brake_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_lap_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_lap_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_lap_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_cones_count_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_cones_count_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_cones_count_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_dv_system_status_cones_count_all_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_cones_count_all_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_cones_count_all_is_in_range(uint32_t value);

/**
 * Pack message mcu_set_ecu_indicator_points.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_mcu_set_ecu_indicator_points_pack(
    uint8_t *dst_p,
    const struct can1_mcu_set_ecu_indicator_points_t *src_p,
    size_t size);

/**
 * Unpack message mcu_set_ecu_indicator_points.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_mcu_set_ecu_indicator_points_unpack(
    struct can1_mcu_set_ecu_indicator_points_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from mcu_set_ecu_indicator_points.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_mcu_set_ecu_indicator_points_init(struct can1_mcu_set_ecu_indicator_points_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_brake_light_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_brake_light_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_brake_light_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_r2d_sound_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_r2d_sound_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_r2d_sound_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_assi_yellow_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_assi_yellow_right_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_assi_yellow_right_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_assi_yellow_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_assi_yellow_left_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_assi_yellow_left_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_assi_yellow_rear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_assi_yellow_rear_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_assi_yellow_rear_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_assi_blue_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_assi_blue_right_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_assi_blue_right_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_assi_blue_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_assi_blue_left_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_assi_blue_left_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ecu_indicator_points_assi_blue_rear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ecu_indicator_points_assi_blue_rear_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ecu_indicator_points_assi_blue_rear_is_in_range(uint8_t value);

/**
 * Pack message mcu_set_dbu_indicator_points.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_mcu_set_dbu_indicator_points_pack(
    uint8_t *dst_p,
    const struct can1_mcu_set_dbu_indicator_points_t *src_p,
    size_t size);

/**
 * Unpack message mcu_set_dbu_indicator_points.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_mcu_set_dbu_indicator_points_unpack(
    struct can1_mcu_set_dbu_indicator_points_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from mcu_set_dbu_indicator_points.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_mcu_set_dbu_indicator_points_init(struct can1_mcu_set_dbu_indicator_points_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_dbu_indicator_points_ts_indicator_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_dbu_indicator_points_ts_indicator_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_dbu_indicator_points_ts_indicator_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_dbu_indicator_points_r2d_indicator_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_dbu_indicator_points_r2d_indicator_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_dbu_indicator_points_r2d_indicator_on_is_in_range(uint8_t value);

/**
 * Pack message res_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_status_pack(
    uint8_t *dst_p,
    const struct can1_res_status_t *src_p,
    size_t size);

/**
 * Unpack message res_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_status_unpack(
    struct can1_res_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from res_status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_res_status_init(struct can1_res_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_e_stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_e_stop_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_e_stop_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_switch_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_switch_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_switch_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_button_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_button_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_button_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_e_stop_redundancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_e_stop_redundancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_e_stop_redundancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_radio_quality_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_radio_quality_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_radio_quality_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_radio_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_radio_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_radio_state_is_in_range(uint8_t value);

/**
 * Pack message res_initialization.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_initialization_pack(
    uint8_t *dst_p,
    const struct can1_res_initialization_t *src_p,
    size_t size);

/**
 * Unpack message res_initialization.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_initialization_unpack(
    struct can1_res_initialization_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from res_initialization.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_res_initialization_init(struct can1_res_initialization_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_initialization_res_init_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_initialization_res_init_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_initialization_res_init_is_in_range(uint8_t value);

/**
 * Pack message res_nmt_node_control.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_nmt_node_control_pack(
    uint8_t *dst_p,
    const struct can1_res_nmt_node_control_t *src_p,
    size_t size);

/**
 * Unpack message res_nmt_node_control.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_nmt_node_control_unpack(
    struct can1_res_nmt_node_control_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from res_nmt_node_control.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_res_nmt_node_control_init(struct can1_res_nmt_node_control_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_nmt_node_control_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_nmt_node_control_requested_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_nmt_node_control_requested_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_nmt_node_control_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_nmt_node_control_node_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_nmt_node_control_node_id_is_in_range(uint8_t value);

/**
 * Pack message swu_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_swu_status_pack(
    uint8_t *dst_p,
    const struct can1_swu_status_t *src_p,
    size_t size);

/**
 * Unpack message swu_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_swu_status_unpack(
    struct can1_swu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from swu_status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_swu_status_init(struct can1_swu_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_rotary_switch_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_rotary_switch_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_rotary_switch_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_rotary_switch_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_rotary_switch_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_rotary_switch_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_rotary_switch_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_rotary_switch_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_rotary_switch_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_rotary_switch_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_rotary_switch_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_rotary_switch_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_encoder_1_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_encoder_1_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_encoder_1_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_encoder_2_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_encoder_2_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_encoder_2_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_swu_status_encoder_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_encoder_1_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_encoder_1_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_swu_status_encoder_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_encoder_2_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_encoder_2_is_in_range(int8_t value);

/**
 * Pack message dbu_status_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dbu_status_1_pack(
    uint8_t *dst_p,
    const struct can1_dbu_status_1_t *src_p,
    size_t size);

/**
 * Unpack message dbu_status_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dbu_status_1_unpack(
    struct can1_dbu_status_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from dbu_status_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_dbu_status_1_init(struct can1_dbu_status_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dbu_status_1_activate_ts_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_1_activate_ts_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_1_activate_ts_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dbu_status_1_ready_to_drive_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_1_ready_to_drive_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_1_ready_to_drive_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dbu_status_1_selected_mission_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_1_selected_mission_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_1_selected_mission_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dbu_status_1_dbu_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_1_dbu_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_1_dbu_temperature_is_in_range(int16_t value);

/**
 * Pack message lv_power_signal.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_lv_power_signal_pack(
    uint8_t *dst_p,
    const struct can1_lv_power_signal_t *src_p,
    size_t size);

/**
 * Unpack message lv_power_signal.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_lv_power_signal_unpack(
    struct can1_lv_power_signal_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from lv_power_signal.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_lv_power_signal_init(struct can1_lv_power_signal_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_power_signal_lv_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_power_signal_lv_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_power_signal_lv_on_is_in_range(uint8_t value);

/**
 * Pack message lv_bms_data_a.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_lv_bms_data_a_pack(
    uint8_t *dst_p,
    const struct can1_lv_bms_data_a_t *src_p,
    size_t size);

/**
 * Unpack message lv_bms_data_a.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_lv_bms_data_a_unpack(
    struct can1_lv_bms_data_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from lv_bms_data_a.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_lv_bms_data_a_init(struct can1_lv_bms_data_a_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_data_multiplexor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_data_multiplexor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_data_multiplexor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_voltage_cell_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_voltage_cell_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_voltage_cell_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_soc_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_soc_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_soc_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_lv_bms_data_a_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_therm1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_therm1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_lv_bms_data_a_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_voltage_cell_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_voltage_cell_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_voltage_cell_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_soc_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_soc_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_soc_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_lv_bms_data_a_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_therm2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_therm2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_lv_bms_data_a_current_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_current_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_current_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_voltage_cell_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_voltage_cell_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_voltage_cell_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_soc_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_soc_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_soc_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_voltage_cell_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_voltage_cell_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_voltage_cell_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_soc_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_soc_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_soc_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_lv_bms_data_a_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_therm3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_therm3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_voltage_cell_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_voltage_cell_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_voltage_cell_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_soc_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_soc_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_soc_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_lv_bms_data_a_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_therm4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_therm4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_lv_bms_data_a_energy_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_energy_count_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_energy_count_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_voltage_cell_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_voltage_cell_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_voltage_cell_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_data_a_soc_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_soc_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_soc_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_lv_bms_data_a_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_data_a_therm5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_data_a_therm5_is_in_range(int16_t value);

/**
 * Pack message lv_bms_status_a.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_lv_bms_status_a_pack(
    uint8_t *dst_p,
    const struct can1_lv_bms_status_a_t *src_p,
    size_t size);

/**
 * Unpack message lv_bms_status_a.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_lv_bms_status_a_unpack(
    struct can1_lv_bms_status_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from lv_bms_status_a.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_lv_bms_status_a_init(struct can1_lv_bms_status_a_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_status_a_lv_bms_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_status_a_lv_bms_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_status_a_lv_bms_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_status_a_soc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_status_a_soc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_status_a_soc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_lv_bms_status_a_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_status_a_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_status_a_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_lv_bms_status_a_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_status_a_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_status_a_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_lv_bms_status_a_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_status_a_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_status_a_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_lv_bms_status_a_not_battery_output_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_lv_bms_status_a_not_battery_output_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_lv_bms_status_a_not_battery_output_enable_is_in_range(uint8_t value);

/**
 * Pack message ams_temperatures.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_temperatures_pack(
    uint8_t *dst_p,
    const struct can1_ams_temperatures_t *src_p,
    size_t size);

/**
 * Unpack message ams_temperatures.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_temperatures_unpack(
    struct can1_ams_temperatures_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_temperatures.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_temperatures_init(struct can1_ams_temperatures_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_temperatures_pre_charge_resistor_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_temperatures_pre_charge_resistor_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_temperatures_pre_charge_resistor_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_temperatures_fuse_resistor_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_temperatures_fuse_resistor_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_temperatures_fuse_resistor_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_temperatures_aux_1_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_temperatures_aux_1_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_temperatures_aux_1_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_temperatures_aux_2_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_temperatures_aux_2_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_temperatures_aux_2_temperature_is_in_range(int16_t value);

/**
 * Pack message ams_cell_voltages.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_cell_voltages_pack(
    uint8_t *dst_p,
    const struct can1_ams_cell_voltages_t *src_p,
    size_t size);

/**
 * Unpack message ams_cell_voltages.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_cell_voltages_unpack(
    struct can1_ams_cell_voltages_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_cell_voltages.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_cell_voltages_init(struct can1_ams_cell_voltages_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_voltage_multiplexor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_voltage_multiplexor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_voltage_multiplexor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s12_is_in_range(uint8_t value);

/**
 * Pack message ams_cell_temperatures.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_cell_temperatures_pack(
    uint8_t *dst_p,
    const struct can1_ams_cell_temperatures_t *src_p,
    size_t size);

/**
 * Unpack message ams_cell_temperatures.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_cell_temperatures_unpack(
    struct can1_ams_cell_temperatures_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_cell_temperatures.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_cell_temperatures_init(struct can1_ams_cell_temperatures_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_temperatures_temperature_multiplexor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_temperature_multiplexor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_temperature_multiplexor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s12_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s12_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s12_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s12_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s12_is_in_range(int16_t value);

/**
 * Pack message ecu_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ecu_status_pack(
    uint8_t *dst_p,
    const struct can1_ecu_status_t *src_p,
    size_t size);

/**
 * Unpack message ecu_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ecu_status_unpack(
    struct can1_ecu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ecu_status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ecu_status_init(struct can1_ecu_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ecu_status_ts_not_off_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ecu_status_ts_not_off_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ecu_status_ts_not_off_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ecu_status_rst_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ecu_status_rst_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ecu_status_rst_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ecu_status_sidepanel_activate_ts_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ecu_status_sidepanel_activate_ts_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ecu_status_sidepanel_activate_ts_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ecu_status_ts_off_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ecu_status_ts_off_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ecu_status_ts_off_is_in_range(uint8_t value);

/**
 * Pack message ebs_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ebs_status_pack(
    uint8_t *dst_p,
    const struct can1_ebs_status_t *src_p,
    size_t size);

/**
 * Unpack message ebs_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ebs_status_unpack(
    struct can1_ebs_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ebs_status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ebs_status_init(struct can1_ebs_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ebs_status_ebs_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_ebs_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_ebs_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ebs_status_ebs_state_machine_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_ebs_state_machine_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_ebs_state_machine_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ebs_status_ebs_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_ebs_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_ebs_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ebs_status_sdc_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_sdc_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_sdc_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ebs_status_ebs_pressure_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_ebs_pressure_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_ebs_pressure_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ebs_status_ebs_pressure_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_ebs_pressure_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_ebs_pressure_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ebs_status_brake_pressure_front_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_brake_pressure_front_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_brake_pressure_front_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ebs_status_brake_pressure_rear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_brake_pressure_rear_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_brake_pressure_rear_is_in_range(uint16_t value);

/**
 * Pack message fb_pedals.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fb_pedals_pack(
    uint8_t *dst_p,
    const struct can1_fb_pedals_t *src_p,
    size_t size);

/**
 * Unpack message fb_pedals.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fb_pedals_unpack(
    struct can1_fb_pedals_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from fb_pedals.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_fb_pedals_init(struct can1_fb_pedals_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_fb_pedals_apps_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fb_pedals_apps_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fb_pedals_apps_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_fb_pedals_apps_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fb_pedals_apps_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fb_pedals_apps_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_fb_pedals_bpps_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fb_pedals_bpps_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fb_pedals_bpps_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_fb_pedals_bpps_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fb_pedals_bpps_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fb_pedals_bpps_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fb_pedals_bpps_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fb_pedals_bpps_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fb_pedals_bpps_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fb_pedals_apps_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fb_pedals_apps_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fb_pedals_apps_error_is_in_range(uint8_t value);

/**
 * Pack message mcu_set_ccu_cooling_points.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_mcu_set_ccu_cooling_points_pack(
    uint8_t *dst_p,
    const struct can1_mcu_set_ccu_cooling_points_t *src_p,
    size_t size);

/**
 * Unpack message mcu_set_ccu_cooling_points.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_mcu_set_ccu_cooling_points_unpack(
    struct can1_mcu_set_ccu_cooling_points_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from mcu_set_ccu_cooling_points.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_mcu_set_ccu_cooling_points_init(struct can1_mcu_set_ccu_cooling_points_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ccu_cooling_points_fan1_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ccu_cooling_points_fan1_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ccu_cooling_points_fan1_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ccu_cooling_points_fan2_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ccu_cooling_points_fan2_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ccu_cooling_points_fan2_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ccu_cooling_points_fan3_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ccu_cooling_points_fan3_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ccu_cooling_points_fan3_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ccu_cooling_points_pump1_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ccu_cooling_points_pump1_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ccu_cooling_points_pump1_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ccu_cooling_points_pump2_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ccu_cooling_points_pump2_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ccu_cooling_points_pump2_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_mcu_set_ccu_cooling_points_pump3_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_mcu_set_ccu_cooling_points_pump3_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_mcu_set_ccu_cooling_points_pump3_speed_is_in_range(uint8_t value);

/**
 * Pack message ccu_status_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ccu_status_1_pack(
    uint8_t *dst_p,
    const struct can1_ccu_status_1_t *src_p,
    size_t size);

/**
 * Unpack message ccu_status_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ccu_status_1_unpack(
    struct can1_ccu_status_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ccu_status_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ccu_status_1_init(struct can1_ccu_status_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_mux_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_mux_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_mux_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_fan1_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_fan1_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_fan1_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_fan2_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_fan2_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_fan2_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_fan3_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_fan3_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_fan3_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_fron_pump_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_fron_pump_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_fron_pump_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_rear_pump_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_rear_pump_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_rear_pump_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_inverter_pump_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_inverter_pump_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_inverter_pump_temperature_is_in_range(uint8_t value);

/**
 * Pack message ccu_status_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ccu_status_2_pack(
    uint8_t *dst_p,
    const struct can1_ccu_status_2_t *src_p,
    size_t size);

/**
 * Unpack message ccu_status_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ccu_status_2_unpack(
    struct can1_ccu_status_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ccu_status_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ccu_status_2_init(struct can1_ccu_status_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_2_digital_input_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_digital_input_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_digital_input_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_2_discharge_relay_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_discharge_relay_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_discharge_relay_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ccu_status_2_discharge_resistor_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_discharge_resistor_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_discharge_resistor_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ccu_status_2_extra_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_extra_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_extra_temperature_is_in_range(int16_t value);

/**
 * Pack message vehicle_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vehicle_status_pack(
    uint8_t *dst_p,
    const struct can1_vehicle_status_t *src_p,
    size_t size);

/**
 * Unpack message vehicle_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vehicle_status_unpack(
    struct can1_vehicle_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vehicle_status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vehicle_status_init(struct can1_vehicle_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_car_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_car_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_car_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_car_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_car_velocity_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_car_velocity_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_vehicle_status_car_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_car_power_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_car_power_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_car_regen_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_car_regen_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_car_regen_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_ready_to_drive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_ready_to_drive_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_ready_to_drive_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_torque_vectoring_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_torque_vectoring_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_torque_vectoring_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_traction_control_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_traction_control_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_traction_control_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_abs_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_abs_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_abs_on_is_in_range(uint8_t value);

/**
 * Pack message fault.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fault_pack(
    uint8_t *dst_p,
    const struct can1_fault_t *src_p,
    size_t size);

/**
 * Unpack message fault.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fault_unpack(
    struct can1_fault_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from fault.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_fault_init(struct can1_fault_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_unit_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_unit_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_unit_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_apps_discrepancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_apps_discrepancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_apps_discrepancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_sc_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_sc_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_sc_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_ts_off_watchdog_triggered_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_ts_off_watchdog_triggered_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_ts_off_watchdog_triggered_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_bpps_discrepancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_bpps_discrepancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_bpps_discrepancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_brake_pressure_discrepancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_brake_pressure_discrepancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_brake_pressure_discrepancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_steering_angle_discrepancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_steering_angle_discrepancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_steering_angle_discrepancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_apps_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_apps_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_apps_out_of_range_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_bpps_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_bpps_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_bpps_out_of_range_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_brake_pressure_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_brake_pressure_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_brake_pressure_out_of_range_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_steering_angle_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_steering_angle_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_steering_angle_out_of_range_is_in_range(uint8_t value);

/**
 * Pack message steering.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_steering_pack(
    uint8_t *dst_p,
    const struct can1_steering_t *src_p,
    size_t size);

/**
 * Unpack message steering.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_steering_unpack(
    struct can1_steering_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from steering.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_steering_init(struct can1_steering_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_steering_steering_angle_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_steering_steering_angle_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_steering_steering_angle_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_steering_steering_angle_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_steering_steering_angle_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_steering_steering_angle_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_steering_steering_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_steering_steering_angle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_steering_steering_angle_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_steering_steering_angle_normalized_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_steering_steering_angle_normalized_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_steering_steering_angle_normalized_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_steering_steering_angle_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_steering_steering_angle_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_steering_steering_angle_error_is_in_range(uint8_t value);

/**
 * Pack message dbu_status_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dbu_status_2_pack(
    uint8_t *dst_p,
    const struct can1_dbu_status_2_t *src_p,
    size_t size);

/**
 * Unpack message dbu_status_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dbu_status_2_unpack(
    struct can1_dbu_status_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from dbu_status_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_dbu_status_2_init(struct can1_dbu_status_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dbu_status_2_screen_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_2_screen_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_2_screen_id_is_in_range(uint8_t value);

/**
 * Pack message dv_control_target.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_control_target_pack(
    uint8_t *dst_p,
    const struct can1_dv_control_target_t *src_p,
    size_t size);

/**
 * Unpack message dv_control_target.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_control_target_unpack(
    struct can1_dv_control_target_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from dv_control_target.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_dv_control_target_init(struct can1_dv_control_target_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dv_control_target_dv_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_speed_target_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_speed_target_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dv_control_target_dv_steering_angle_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_steering_angle_target_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_steering_angle_target_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_control_target_dv_brake_hydralic_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_brake_hydralic_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_brake_hydralic_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dv_control_target_dv_motor_moment_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_motor_moment_target_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_motor_moment_target_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_control_target_dv_mission_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_mission_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_mission_status_is_in_range(uint8_t value);

/**
 * Pack message vehicle_status_wheel_speed.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vehicle_status_wheel_speed_pack(
    uint8_t *dst_p,
    const struct can1_vehicle_status_wheel_speed_t *src_p,
    size_t size);

/**
 * Unpack message vehicle_status_wheel_speed.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vehicle_status_wheel_speed_unpack(
    struct can1_vehicle_status_wheel_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vehicle_status_wheel_speed.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vehicle_status_wheel_speed_init(struct can1_vehicle_status_wheel_speed_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_speed_wheel_speed_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_speed_wheel_speed_fl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_speed_wheel_speed_fl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_speed_wheel_speed_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_speed_wheel_speed_fr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_speed_wheel_speed_fr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_speed_wheel_speed_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_speed_wheel_speed_rl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_speed_wheel_speed_rl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_speed_wheel_speed_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_speed_wheel_speed_rr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_speed_wheel_speed_rr_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_HDT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_hdt_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_hdt_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_HDT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_hdt_unpack(
    struct can1_sbg_ecan_msg_gps2_hdt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS2_HDT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps2_hdt_init(struct can1_sbg_ecan_msg_gps2_hdt_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_hdt_true_heading_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_hdt_true_heading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_hdt_true_heading_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_hdt_true_heading_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_hdt_true_heading_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_hdt_true_heading_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_hdt_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_hdt_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_hdt_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_hdt_pitch_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_hdt_pitch_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_hdt_pitch_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_HDT_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_hdt_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_hdt_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_HDT_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_hdt_info_unpack(
    struct can1_sbg_ecan_msg_gps2_hdt_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS2_HDT_INFO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps2_hdt_info_init(struct can1_sbg_ecan_msg_gps2_hdt_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps2_hdt_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_hdt_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_hdt_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_hdt_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_hdt_info_status_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_hdt_info_status_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_POS_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_pos_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_POS_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_acc_unpack(
    struct can1_sbg_ecan_msg_gps2_pos_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS2_POS_ACC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps2_pos_acc_init(struct can1_sbg_ecan_msg_gps2_pos_acc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_pos_acc_latitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_acc_latitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_acc_latitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_pos_acc_longitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_acc_longitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_acc_longitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_pos_acc_altitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_acc_altitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_acc_altitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_pos_acc_base_station_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_acc_base_station_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_acc_base_station_id_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_POS_ALT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_alt_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_pos_alt_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_POS_ALT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_alt_unpack(
    struct can1_sbg_ecan_msg_gps2_pos_alt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS2_POS_ALT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps2_pos_alt_init(struct can1_sbg_ecan_msg_gps2_pos_alt_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_gps2_pos_alt_altitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_alt_altitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_alt_altitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_pos_alt_undulation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_alt_undulation_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_alt_undulation_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_gps2_pos_alt_num_sv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_alt_num_sv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_alt_num_sv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_gps2_pos_alt_diff_corr_age_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_alt_diff_corr_age_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_alt_diff_corr_age_is_in_range(uint8_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_POS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_pos_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_POS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_unpack(
    struct can1_sbg_ecan_msg_gps2_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS2_POS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps2_pos_init(struct can1_sbg_ecan_msg_gps2_pos_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_gps2_pos_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_gps2_pos_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_longitude_is_in_range(int32_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_POS_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_pos_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_POS_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_pos_info_unpack(
    struct can1_sbg_ecan_msg_gps2_pos_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS2_POS_INFO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps2_pos_info_init(struct can1_sbg_ecan_msg_gps2_pos_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps2_pos_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps2_pos_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_pos_info_status_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_pos_info_status_is_in_range(uint32_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_VEL_COURSE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_course_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_vel_course_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_VEL_COURSE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_course_unpack(
    struct can1_sbg_ecan_msg_gps2_vel_course_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS2_VEL_COURSE.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps2_vel_course_init(struct can1_sbg_ecan_msg_gps2_vel_course_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_vel_course_course_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_course_course_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_course_course_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps2_vel_course_course_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_course_course_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_course_course_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_VEL_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_vel_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_VEL_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_acc_unpack(
    struct can1_sbg_ecan_msg_gps2_vel_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS2_VEL_ACC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps2_vel_acc_init(struct can1_sbg_ecan_msg_gps2_vel_acc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_acc_velocity_acc_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_vel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_unpack(
    struct can1_sbg_ecan_msg_gps2_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS2_VEL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps2_vel_init(struct can1_sbg_ecan_msg_gps2_vel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_vel_velocity_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_velocity_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_velocity_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_vel_velocity_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_velocity_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_velocity_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps2_vel_velocity_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_velocity_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_velocity_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS2_VEL_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps2_vel_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS2_VEL_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps2_vel_info_unpack(
    struct can1_sbg_ecan_msg_gps2_vel_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS2_VEL_INFO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps2_vel_info_init(struct can1_sbg_ecan_msg_gps2_vel_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps2_vel_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps2_vel_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps2_vel_info_status_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps2_vel_info_status_is_in_range(uint32_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_HDT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_hdt_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_hdt_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_HDT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_hdt_unpack(
    struct can1_sbg_ecan_msg_gps1_hdt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS1_HDT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps1_hdt_init(struct can1_sbg_ecan_msg_gps1_hdt_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_hdt_true_heading_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_true_heading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_true_heading_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_hdt_true_heading_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_true_heading_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_true_heading_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_hdt_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_hdt_pitch_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_pitch_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_pitch_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_HDT_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_hdt_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_hdt_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_HDT_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_hdt_info_unpack(
    struct can1_sbg_ecan_msg_gps1_hdt_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS1_HDT_INFO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps1_hdt_info_init(struct can1_sbg_ecan_msg_gps1_hdt_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps1_hdt_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_hdt_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_info_status_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_info_status_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_POS_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_pos_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_POS_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_acc_unpack(
    struct can1_sbg_ecan_msg_gps1_pos_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS1_POS_ACC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps1_pos_acc_init(struct can1_sbg_ecan_msg_gps1_pos_acc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_pos_acc_latitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_acc_latitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_acc_latitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_pos_acc_longitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_acc_longitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_acc_longitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_pos_acc_altitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_acc_altitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_acc_altitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_pos_acc_base_station_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_acc_base_station_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_acc_base_station_id_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_POS_ALT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_alt_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_pos_alt_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_POS_ALT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_alt_unpack(
    struct can1_sbg_ecan_msg_gps1_pos_alt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS1_POS_ALT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps1_pos_alt_init(struct can1_sbg_ecan_msg_gps1_pos_alt_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_gps1_pos_alt_altitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_alt_altitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_alt_altitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_pos_alt_undulation_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_alt_undulation_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_alt_undulation_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_gps1_pos_alt_num_sv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_alt_num_sv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_alt_num_sv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_alt_diff_corr_age_is_in_range(uint8_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_POS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_pos_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_POS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_unpack(
    struct can1_sbg_ecan_msg_gps1_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS1_POS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps1_pos_init(struct can1_sbg_ecan_msg_gps1_pos_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_gps1_pos_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_gps1_pos_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_longitude_is_in_range(int32_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_POS_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_pos_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_POS_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_pos_info_unpack(
    struct can1_sbg_ecan_msg_gps1_pos_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS1_POS_INFO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps1_pos_info_init(struct can1_sbg_ecan_msg_gps1_pos_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps1_pos_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps1_pos_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_pos_info_status_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_pos_info_status_is_in_range(uint32_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_VEL_COURSE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_course_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_vel_course_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_VEL_COURSE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_course_unpack(
    struct can1_sbg_ecan_msg_gps1_vel_course_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS1_VEL_COURSE.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps1_vel_course_init(struct can1_sbg_ecan_msg_gps1_vel_course_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_vel_course_course_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_course_course_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_course_course_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_vel_course_course_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_course_course_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_course_course_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_VEL_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_vel_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_VEL_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_acc_unpack(
    struct can1_sbg_ecan_msg_gps1_vel_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS1_VEL_ACC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps1_vel_acc_init(struct can1_sbg_ecan_msg_gps1_vel_acc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_acc_velocity_acc_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_vel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_unpack(
    struct can1_sbg_ecan_msg_gps1_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS1_VEL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps1_vel_init(struct can1_sbg_ecan_msg_gps1_vel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_vel_velocity_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_velocity_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_velocity_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_vel_velocity_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_velocity_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_velocity_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_vel_velocity_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_velocity_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_velocity_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_VEL_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_vel_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_VEL_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_vel_info_unpack(
    struct can1_sbg_ecan_msg_gps1_vel_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_GPS1_VEL_INFO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_gps1_vel_info_init(struct can1_sbg_ecan_msg_gps1_vel_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps1_vel_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps1_vel_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_vel_info_status_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_vel_info_status_is_in_range(uint32_t value);

/**
 * Pack message SBG_ECAN_MSG_ODO_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_odo_vel_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_odo_vel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_ODO_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_odo_vel_unpack(
    struct can1_sbg_ecan_msg_odo_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_ODO_VEL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_odo_vel_init(struct can1_sbg_ecan_msg_odo_vel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_odo_vel_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_odo_vel_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_odo_vel_velocity_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_ODO_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_odo_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_odo_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_ODO_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_odo_info_unpack(
    struct can1_sbg_ecan_msg_odo_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_ODO_INFO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_odo_info_init(struct can1_sbg_ecan_msg_odo_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_odo_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_odo_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_odo_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_odo_info_odo_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_odo_info_odo_status_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_odo_info_odo_status_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_VEL_BODY.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_body_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_vel_body_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_VEL_BODY.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_body_unpack(
    struct can1_sbg_ecan_msg_ekf_vel_body_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_EKF_VEL_BODY.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_ekf_vel_body_init(struct can1_sbg_ecan_msg_ekf_vel_body_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_body_velocity_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_body_velocity_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_body_velocity_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_body_velocity_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_body_velocity_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_body_velocity_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_body_velocity_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_body_velocity_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_body_velocity_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_VEL_NED_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_vel_ned_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_VEL_NED_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_acc_unpack(
    struct can1_sbg_ecan_msg_ekf_vel_ned_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_EKF_VEL_NED_ACC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_acc_init(struct can1_sbg_ecan_msg_ekf_vel_ned_acc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_vel_ned_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_unpack(
    struct can1_sbg_ecan_msg_ekf_vel_ned_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_init(struct can1_sbg_ecan_msg_ekf_vel_ned_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_velocity_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_velocity_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_velocity_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_velocity_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_velocity_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_velocity_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_velocity_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_velocity_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_velocity_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_POS_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_pos_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_pos_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_POS_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_pos_acc_unpack(
    struct can1_sbg_ecan_msg_ekf_pos_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_EKF_POS_ACC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_ekf_pos_acc_init(struct can1_sbg_ecan_msg_ekf_pos_acc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_pos_acc_latitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_acc_latitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_acc_latitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_pos_acc_longitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_acc_longitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_acc_longitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_pos_acc_altitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_acc_altitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_acc_altitude_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_POS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_pos_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_pos_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_POS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_pos_unpack(
    struct can1_sbg_ecan_msg_ekf_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_EKF_POS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_ekf_pos_init(struct can1_sbg_ecan_msg_ekf_pos_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_ekf_pos_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_ekf_pos_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_longitude_is_in_range(int32_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_ORIENTATION_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_orientation_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_orientation_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_ORIENTATION_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_orientation_acc_unpack(
    struct can1_sbg_ecan_msg_ekf_orientation_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_EKF_ORIENTATION_ACC.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_ekf_orientation_acc_init(struct can1_sbg_ecan_msg_ekf_orientation_acc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_orientation_acc_roll_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_orientation_acc_roll_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_orientation_acc_roll_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_orientation_acc_pitch_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_orientation_acc_pitch_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_orientation_acc_pitch_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_orientation_acc_yaw_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_orientation_acc_yaw_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_orientation_acc_yaw_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_EULER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_euler_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_euler_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_EULER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_euler_unpack(
    struct can1_sbg_ecan_msg_ekf_euler_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_EKF_EULER.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_ekf_euler_init(struct can1_sbg_ecan_msg_ekf_euler_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_euler_roll_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_euler_roll_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_euler_roll_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_euler_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_euler_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_euler_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_euler_yaw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_euler_yaw_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_euler_yaw_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_QUAT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_quat_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_quat_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_QUAT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_quat_unpack(
    struct can1_sbg_ecan_msg_ekf_quat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_EKF_QUAT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_ekf_quat_init(struct can1_sbg_ecan_msg_ekf_quat_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_quat_q0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_quat_q0_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_quat_q0_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_quat_q1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_quat_q1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_quat_q1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_quat_q2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_quat_q2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_quat_q2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_quat_q3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_quat_q3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_quat_q3_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_info_unpack(
    struct can1_sbg_ecan_msg_ekf_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_EKF_INFO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_ekf_info_init(struct can1_sbg_ecan_msg_ekf_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_ekf_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_info_time_stamp_is_in_range(uint32_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_DELTA_ANGLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_imu_delta_angle_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_imu_delta_angle_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_DELTA_ANGLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_imu_delta_angle_unpack(
    struct can1_sbg_ecan_msg_imu_delta_angle_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_IMU_DELTA_ANGLE.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_imu_delta_angle_init(struct can1_sbg_ecan_msg_imu_delta_angle_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_delta_angle_delta_angle_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_delta_angle_delta_angle_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_delta_angle_delta_angle_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_delta_angle_delta_angle_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_delta_angle_delta_angle_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_delta_angle_delta_angle_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_delta_angle_delta_angle_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_delta_angle_delta_angle_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_delta_angle_delta_angle_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_DELTA_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_imu_delta_vel_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_imu_delta_vel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_DELTA_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_imu_delta_vel_unpack(
    struct can1_sbg_ecan_msg_imu_delta_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_IMU_DELTA_VEL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_imu_delta_vel_init(struct can1_sbg_ecan_msg_imu_delta_vel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_delta_vel_delta_vel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_delta_vel_delta_vel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_delta_vel_delta_vel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_delta_vel_delta_vel_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_delta_vel_delta_vel_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_delta_vel_delta_vel_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_delta_vel_delta_vel_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_delta_vel_delta_vel_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_delta_vel_delta_vel_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_GYRO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_imu_gyro_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_imu_gyro_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_GYRO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_imu_gyro_unpack(
    struct can1_sbg_ecan_msg_imu_gyro_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_IMU_GYRO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_imu_gyro_init(struct can1_sbg_ecan_msg_imu_gyro_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_gyro_gyro_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_gyro_gyro_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_gyro_gyro_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_gyro_gyro_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_gyro_gyro_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_gyro_gyro_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_gyro_gyro_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_gyro_gyro_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_gyro_gyro_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_ACCEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_imu_accel_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_imu_accel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_ACCEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_imu_accel_unpack(
    struct can1_sbg_ecan_msg_imu_accel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_IMU_ACCEL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_imu_accel_init(struct can1_sbg_ecan_msg_imu_accel_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_accel_accel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_accel_accel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_accel_accel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_accel_accel_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_accel_accel_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_accel_accel_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_accel_accel_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_accel_accel_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_accel_accel_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_imu_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_imu_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_imu_info_unpack(
    struct can1_sbg_ecan_msg_imu_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_IMU_INFO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_imu_info_init(struct can1_sbg_ecan_msg_imu_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_imu_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_imu_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_info_status_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_info_status_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_info_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_info_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_info_temperature_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_UTC_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_utc_1_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_utc_1_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_UTC_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_utc_1_unpack(
    struct can1_sbg_ecan_msg_utc_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_UTC_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_utc_1_init(struct can1_sbg_ecan_msg_utc_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_utc_1_year_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_year_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_year_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_utc_1_month_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_month_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_month_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_utc_1_day_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_day_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_day_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_utc_1_hour_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_hour_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_hour_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_utc_1_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_min_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_min_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_utc_1_sec_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_sec_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_sec_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_utc_1_micro_sec_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_1_micro_sec_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_1_micro_sec_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_UTC_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_utc_0_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_utc_0_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_UTC_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_utc_0_unpack(
    struct can1_sbg_ecan_msg_utc_0_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_UTC_0.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_utc_0_init(struct can1_sbg_ecan_msg_utc_0_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_utc_0_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_0_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_0_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_utc_0_gps_tow_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_utc_0_gps_tow_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_utc_0_gps_tow_is_in_range(uint32_t value);

/**
 * Pack message FS_Datalogger_Reserved_6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_reserved_6_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_reserved_6_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Reserved_6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_reserved_6_unpack(
    struct can1_fs_datalogger_reserved_6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FS_Datalogger_Reserved_6.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_fs_datalogger_reserved_6_init(struct can1_fs_datalogger_reserved_6_t *msg_p);

/**
 * Pack message FS_Datalogger_Reserved_5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_reserved_5_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_reserved_5_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Reserved_5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_reserved_5_unpack(
    struct can1_fs_datalogger_reserved_5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FS_Datalogger_Reserved_5.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_fs_datalogger_reserved_5_init(struct can1_fs_datalogger_reserved_5_t *msg_p);

/**
 * Pack message FS_Datalogger_Reserved_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_reserved_4_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_reserved_4_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Reserved_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_reserved_4_unpack(
    struct can1_fs_datalogger_reserved_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FS_Datalogger_Reserved_4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_fs_datalogger_reserved_4_init(struct can1_fs_datalogger_reserved_4_t *msg_p);

/**
 * Pack message FS_Datalogger_Reserved_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_reserved_3_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_reserved_3_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Reserved_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_reserved_3_unpack(
    struct can1_fs_datalogger_reserved_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FS_Datalogger_Reserved_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_fs_datalogger_reserved_3_init(struct can1_fs_datalogger_reserved_3_t *msg_p);

/**
 * Pack message FS_Datalogger_Reserved_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_reserved_2_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_reserved_2_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Reserved_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_reserved_2_unpack(
    struct can1_fs_datalogger_reserved_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FS_Datalogger_Reserved_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_fs_datalogger_reserved_2_init(struct can1_fs_datalogger_reserved_2_t *msg_p);

/**
 * Pack message FS_Datalogger_Reserved_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_reserved_1_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_reserved_1_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Reserved_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_reserved_1_unpack(
    struct can1_fs_datalogger_reserved_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FS_Datalogger_Reserved_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_fs_datalogger_reserved_1_init(struct can1_fs_datalogger_reserved_1_t *msg_p);

/**
 * Pack message FS_Datalogger_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fs_datalogger_status_pack(
    uint8_t *dst_p,
    const struct can1_fs_datalogger_status_t *src_p,
    size_t size);

/**
 * Unpack message FS_Datalogger_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fs_datalogger_status_unpack(
    struct can1_fs_datalogger_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FS_Datalogger_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_fs_datalogger_status_init(struct can1_fs_datalogger_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fs_datalogger_status_msg_cnt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_msg_cnt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_msg_cnt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_fs_datalogger_status_status_ready_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_status_ready_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_status_ready_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_fs_datalogger_status_status_logging_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_status_logging_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_status_logging_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_fs_datalogger_status_status_triggered_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_status_triggered_voltage_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_status_triggered_voltage_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_fs_datalogger_status_status_triggered_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_status_triggered_current_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_status_triggered_current_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_fs_datalogger_status_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_fs_datalogger_status_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fs_datalogger_status_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fs_datalogger_status_current_is_in_range(uint16_t value);

/**
 * Pack message vesc_status_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vesc_status_2_pack(
    uint8_t *dst_p,
    const struct can1_vesc_status_2_t *src_p,
    size_t size);

/**
 * Unpack message vesc_status_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vesc_status_2_unpack(
    struct can1_vesc_status_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vesc_status_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vesc_status_2_init(struct can1_vesc_status_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_vesc_status_2_amp_hours_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_2_amp_hours_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_2_amp_hours_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_vesc_status_2_amp_hours_chg_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_2_amp_hours_chg_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_2_amp_hours_chg_is_in_range(int32_t value);

/**
 * Pack message vesc_status_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vesc_status_4_pack(
    uint8_t *dst_p,
    const struct can1_vesc_status_4_t *src_p,
    size_t size);

/**
 * Unpack message vesc_status_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vesc_status_4_unpack(
    struct can1_vesc_status_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vesc_status_4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vesc_status_4_init(struct can1_vesc_status_4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_4_temp_fet_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_4_temp_fet_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_4_temp_fet_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_4_temp_motor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_4_temp_motor_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_4_temp_motor_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_4_current_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_4_current_in_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_4_current_in_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_4_pid_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_4_pid_pos_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_4_pid_pos_is_in_range(int16_t value);

/**
 * Pack message vesc_status_5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vesc_status_5_pack(
    uint8_t *dst_p,
    const struct can1_vesc_status_5_t *src_p,
    size_t size);

/**
 * Unpack message vesc_status_5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vesc_status_5_unpack(
    struct can1_vesc_status_5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vesc_status_5.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vesc_status_5_init(struct can1_vesc_status_5_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_vesc_status_5_tachometer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_5_tachometer_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_5_tachometer_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_5_volts_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_5_volts_in_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_5_volts_in_is_in_range(int16_t value);

/**
 * Pack message vesc_status_6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vesc_status_6_pack(
    uint8_t *dst_p,
    const struct can1_vesc_status_6_t *src_p,
    size_t size);

/**
 * Unpack message vesc_status_6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vesc_status_6_unpack(
    struct can1_vesc_status_6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vesc_status_6.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vesc_status_6_init(struct can1_vesc_status_6_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_6_adc1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_6_adc1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_6_adc1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_6_adc2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_6_adc2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_6_adc2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_6_adc3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_6_adc3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_6_adc3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_6_ppm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_6_ppm_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_6_ppm_is_in_range(int16_t value);

/**
 * Pack message vesc_set_duty.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vesc_set_duty_pack(
    uint8_t *dst_p,
    const struct can1_vesc_set_duty_t *src_p,
    size_t size);

/**
 * Unpack message vesc_set_duty.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vesc_set_duty_unpack(
    struct can1_vesc_set_duty_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vesc_set_duty.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vesc_set_duty_init(struct can1_vesc_set_duty_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_vesc_set_duty_set_duty_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_set_duty_set_duty_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_set_duty_set_duty_is_in_range(int32_t value);

/**
 * Pack message vesc_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vesc_status_pack(
    uint8_t *dst_p,
    const struct can1_vesc_status_t *src_p,
    size_t size);

/**
 * Unpack message vesc_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vesc_status_unpack(
    struct can1_vesc_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vesc_status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vesc_status_init(struct can1_vesc_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_vesc_status_erpm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_erpm_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_erpm_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vesc_status_duty_cycle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vesc_status_duty_cycle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vesc_status_duty_cycle_is_in_range(int16_t value);

/**
 * Pack message ams_s1_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s1_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s1_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s1_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s1_voltages_1_unpack(
    struct can1_ams_s1_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s1_voltages_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s1_voltages_1_init(struct can1_ams_s1_voltages_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_1_s1v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_1_s1v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_1_s1v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_1_s1v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_1_s1v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_1_s1v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_1_s1v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_1_s1v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_1_s1v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_1_s1v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_1_s1v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_1_s1v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_1_s1v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_1_s1v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_1_s1v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_1_s1v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_1_s1v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_1_s1v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s1_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s1_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s1_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s1_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s1_voltages_2_unpack(
    struct can1_ams_s1_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s1_voltages_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s1_voltages_2_init(struct can1_ams_s1_voltages_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_2_s1v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_2_s1v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_2_s1v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_2_s1v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_2_s1v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_2_s1v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_2_s1v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_2_s1v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_2_s1v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_2_s1v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_2_s1v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_2_s1v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s1_voltages_2_s1v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s1_voltages_2_s1v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s1_voltages_2_s1v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s2_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s2_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s2_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s2_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s2_voltages_1_unpack(
    struct can1_ams_s2_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s2_voltages_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s2_voltages_1_init(struct can1_ams_s2_voltages_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_1_s2v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_1_s2v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_1_s2v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_1_s2v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_1_s2v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_1_s2v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_1_s2v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_1_s2v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_1_s2v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_1_s2v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_1_s2v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_1_s2v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_1_s2v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_1_s2v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_1_s2v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_1_s2v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_1_s2v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_1_s2v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s2_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s2_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s2_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s2_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s2_voltages_2_unpack(
    struct can1_ams_s2_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s2_voltages_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s2_voltages_2_init(struct can1_ams_s2_voltages_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_2_s2v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_2_s2v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_2_s2v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_2_s2v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_2_s2v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_2_s2v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_2_s2v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_2_s2v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_2_s2v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_2_s2v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_2_s2v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_2_s2v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s2_voltages_2_s2v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s2_voltages_2_s2v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s2_voltages_2_s2v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s3_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s3_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s3_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s3_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s3_voltages_1_unpack(
    struct can1_ams_s3_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s3_voltages_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s3_voltages_1_init(struct can1_ams_s3_voltages_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_1_s3v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_1_s3v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_1_s3v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_1_s3v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_1_s3v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_1_s3v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_1_s3v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_1_s3v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_1_s3v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_1_s3v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_1_s3v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_1_s3v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_1_s3v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_1_s3v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_1_s3v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_1_s3v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_1_s3v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_1_s3v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s3_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s3_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s3_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s3_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s3_voltages_2_unpack(
    struct can1_ams_s3_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s3_voltages_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s3_voltages_2_init(struct can1_ams_s3_voltages_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_2_s3v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_2_s3v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_2_s3v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_2_s3v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_2_s3v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_2_s3v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_2_s3v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_2_s3v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_2_s3v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_2_s3v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_2_s3v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_2_s3v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s3_voltages_2_s3v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s3_voltages_2_s3v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s3_voltages_2_s3v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s4_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s4_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s4_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s4_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s4_voltages_1_unpack(
    struct can1_ams_s4_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s4_voltages_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s4_voltages_1_init(struct can1_ams_s4_voltages_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_1_s4v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_1_s4v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_1_s4v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_1_s4v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_1_s4v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_1_s4v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_1_s4v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_1_s4v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_1_s4v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_1_s4v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_1_s4v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_1_s4v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_1_s4v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_1_s4v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_1_s4v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_1_s4v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_1_s4v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_1_s4v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s4_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s4_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s4_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s4_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s4_voltages_2_unpack(
    struct can1_ams_s4_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s4_voltages_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s4_voltages_2_init(struct can1_ams_s4_voltages_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_2_s4v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_2_s4v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_2_s4v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_2_s4v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_2_s4v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_2_s4v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_2_s4v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_2_s4v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_2_s4v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_2_s4v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_2_s4v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_2_s4v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s4_voltages_2_s4v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s4_voltages_2_s4v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s4_voltages_2_s4v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s5_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s5_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s5_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s5_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s5_voltages_1_unpack(
    struct can1_ams_s5_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s5_voltages_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s5_voltages_1_init(struct can1_ams_s5_voltages_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_1_s5v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_1_s5v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_1_s5v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_1_s5v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_1_s5v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_1_s5v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_1_s5v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_1_s5v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_1_s5v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_1_s5v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_1_s5v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_1_s5v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_1_s5v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_1_s5v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_1_s5v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_1_s5v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_1_s5v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_1_s5v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s5_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s5_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s5_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s5_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s5_voltages_2_unpack(
    struct can1_ams_s5_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s5_voltages_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s5_voltages_2_init(struct can1_ams_s5_voltages_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_2_s5v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_2_s5v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_2_s5v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_2_s5v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_2_s5v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_2_s5v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_2_s5v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_2_s5v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_2_s5v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_2_s5v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_2_s5v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_2_s5v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s5_voltages_2_s5v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s5_voltages_2_s5v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s5_voltages_2_s5v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s6_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s6_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s6_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s6_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s6_voltages_1_unpack(
    struct can1_ams_s6_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s6_voltages_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s6_voltages_1_init(struct can1_ams_s6_voltages_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_1_s6v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_1_s6v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_1_s6v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_1_s6v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_1_s6v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_1_s6v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_1_s6v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_1_s6v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_1_s6v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_1_s6v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_1_s6v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_1_s6v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_1_s6v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_1_s6v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_1_s6v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_1_s6v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_1_s6v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_1_s6v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s6_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s6_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s6_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s6_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s6_voltages_2_unpack(
    struct can1_ams_s6_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s6_voltages_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s6_voltages_2_init(struct can1_ams_s6_voltages_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_2_s6v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_2_s6v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_2_s6v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_2_s6v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_2_s6v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_2_s6v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_2_s6v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_2_s6v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_2_s6v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_2_s6v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_2_s6v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_2_s6v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s6_voltages_2_s6v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s6_voltages_2_s6v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s6_voltages_2_s6v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s7_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s7_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s7_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s7_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s7_voltages_1_unpack(
    struct can1_ams_s7_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s7_voltages_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s7_voltages_1_init(struct can1_ams_s7_voltages_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_1_s7v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_1_s7v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_1_s7v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_1_s7v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_1_s7v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_1_s7v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_1_s7v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_1_s7v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_1_s7v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_1_s7v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_1_s7v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_1_s7v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_1_s7v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_1_s7v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_1_s7v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_1_s7v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_1_s7v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_1_s7v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s7_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s7_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s7_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s7_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s7_voltages_2_unpack(
    struct can1_ams_s7_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s7_voltages_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s7_voltages_2_init(struct can1_ams_s7_voltages_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_2_s7v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_2_s7v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_2_s7v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_2_s7v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_2_s7v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_2_s7v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_2_s7v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_2_s7v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_2_s7v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_2_s7v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_2_s7v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_2_s7v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s7_voltages_2_s7v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s7_voltages_2_s7v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s7_voltages_2_s7v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s8_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s8_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s8_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s8_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s8_voltages_1_unpack(
    struct can1_ams_s8_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s8_voltages_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s8_voltages_1_init(struct can1_ams_s8_voltages_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_1_s8v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_1_s8v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_1_s8v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_1_s8v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_1_s8v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_1_s8v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_1_s8v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_1_s8v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_1_s8v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_1_s8v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_1_s8v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_1_s8v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_1_s8v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_1_s8v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_1_s8v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_1_s8v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_1_s8v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_1_s8v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s8_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s8_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s8_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s8_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s8_voltages_2_unpack(
    struct can1_ams_s8_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s8_voltages_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s8_voltages_2_init(struct can1_ams_s8_voltages_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_2_s8v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_2_s8v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_2_s8v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_2_s8v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_2_s8v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_2_s8v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_2_s8v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_2_s8v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_2_s8v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_2_s8v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_2_s8v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_2_s8v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s8_voltages_2_s8v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s8_voltages_2_s8v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s8_voltages_2_s8v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s9_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s9_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s9_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s9_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s9_voltages_1_unpack(
    struct can1_ams_s9_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s9_voltages_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s9_voltages_1_init(struct can1_ams_s9_voltages_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_1_s9v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_1_s9v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_1_s9v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_1_s9v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_1_s9v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_1_s9v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_1_s9v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_1_s9v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_1_s9v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_1_s9v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_1_s9v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_1_s9v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_1_s9v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_1_s9v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_1_s9v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_1_s9v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_1_s9v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_1_s9v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s9_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s9_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s9_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s9_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s9_voltages_2_unpack(
    struct can1_ams_s9_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s9_voltages_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s9_voltages_2_init(struct can1_ams_s9_voltages_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_2_s9v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_2_s9v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_2_s9v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_2_s9v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_2_s9v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_2_s9v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_2_s9v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_2_s9v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_2_s9v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_2_s9v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_2_s9v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_2_s9v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s9_voltages_2_s9v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s9_voltages_2_s9v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s9_voltages_2_s9v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s10_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s10_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s10_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s10_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s10_voltages_1_unpack(
    struct can1_ams_s10_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s10_voltages_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s10_voltages_1_init(struct can1_ams_s10_voltages_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_1_s10v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_1_s10v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_1_s10v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_1_s10v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_1_s10v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_1_s10v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_1_s10v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_1_s10v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_1_s10v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_1_s10v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_1_s10v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_1_s10v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_1_s10v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_1_s10v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_1_s10v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_1_s10v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_1_s10v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_1_s10v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s10_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s10_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s10_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s10_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s10_voltages_2_unpack(
    struct can1_ams_s10_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s10_voltages_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s10_voltages_2_init(struct can1_ams_s10_voltages_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_2_s10v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_2_s10v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_2_s10v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_2_s10v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_2_s10v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_2_s10v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_2_s10v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_2_s10v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_2_s10v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_2_s10v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_2_s10v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_2_s10v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s10_voltages_2_s10v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s10_voltages_2_s10v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s10_voltages_2_s10v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s11_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s11_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s11_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s11_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s11_voltages_1_unpack(
    struct can1_ams_s11_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s11_voltages_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s11_voltages_1_init(struct can1_ams_s11_voltages_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_1_s11v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_1_s11v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_1_s11v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_1_s11v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_1_s11v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_1_s11v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_1_s11v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_1_s11v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_1_s11v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_1_s11v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_1_s11v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_1_s11v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_1_s11v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_1_s11v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_1_s11v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_1_s11v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_1_s11v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_1_s11v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s11_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s11_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s11_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s11_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s11_voltages_2_unpack(
    struct can1_ams_s11_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s11_voltages_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s11_voltages_2_init(struct can1_ams_s11_voltages_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_2_s11v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_2_s11v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_2_s11v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_2_s11v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_2_s11v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_2_s11v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_2_s11v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_2_s11v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_2_s11v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_2_s11v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_2_s11v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_2_s11v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s11_voltages_2_s11v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s11_voltages_2_s11v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s11_voltages_2_s11v11_is_in_range(uint8_t value);

/**
 * Pack message ams_s12_voltages_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s12_voltages_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_s12_voltages_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_s12_voltages_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s12_voltages_1_unpack(
    struct can1_ams_s12_voltages_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s12_voltages_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s12_voltages_1_init(struct can1_ams_s12_voltages_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_1_s12v1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_1_s12v1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_1_s12v1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_1_s12v2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_1_s12v2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_1_s12v2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_1_s12v3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_1_s12v3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_1_s12v3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_1_s12v4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_1_s12v4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_1_s12v4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_1_s12v5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_1_s12v5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_1_s12v5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_1_s12v6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_1_s12v6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_1_s12v6_is_in_range(uint8_t value);

/**
 * Pack message ams_s12_voltages_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_s12_voltages_2_pack(
    uint8_t *dst_p,
    const struct can1_ams_s12_voltages_2_t *src_p,
    size_t size);

/**
 * Unpack message ams_s12_voltages_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_s12_voltages_2_unpack(
    struct can1_ams_s12_voltages_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ams_s12_voltages_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_s12_voltages_2_init(struct can1_ams_s12_voltages_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_2_s12v7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_2_s12v7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_2_s12v7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_2_s12v8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_2_s12v8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_2_s12v8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_2_s12v9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_2_s12v9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_2_s12v9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_2_s12v10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_2_s12v10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_2_s12v10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_s12_voltages_2_s12v11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_s12_voltages_2_s12v11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_s12_voltages_2_s12v11_is_in_range(uint8_t value);

/**
 * Pack message ivt_improved_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ivt_improved_status_pack(
    uint8_t *dst_p,
    const struct can1_ivt_improved_status_t *src_p,
    size_t size);

/**
 * Unpack message ivt_improved_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ivt_improved_status_unpack(
    struct can1_ivt_improved_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ivt_improved_status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ivt_improved_status_init(struct can1_ivt_improved_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ivt_improved_status_ivt_voltage_battery_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_improved_status_ivt_voltage_battery_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_improved_status_ivt_voltage_battery_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ivt_improved_status_ivt_voltage_vehicle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_improved_status_ivt_voltage_vehicle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_improved_status_ivt_voltage_vehicle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ivt_improved_status_ivt_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_improved_status_ivt_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_improved_status_ivt_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ivt_improved_status_temp_h_vplus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_improved_status_temp_h_vplus_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_improved_status_temp_h_vplus_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ivt_improved_status_temp_h_vminus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_improved_status_temp_h_vminus_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_improved_status_temp_h_vminus_is_in_range(uint8_t value);

/**
 * Pack message res_recieve_PDO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_recieve_pdo_pack(
    uint8_t *dst_p,
    const struct can1_res_recieve_pdo_t *src_p,
    size_t size);

/**
 * Unpack message res_recieve_PDO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_recieve_pdo_unpack(
    struct can1_res_recieve_pdo_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from res_recieve_PDO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_res_recieve_pdo_init(struct can1_res_recieve_pdo_t *msg_p);

/**
 * Pack message res_transmit_SDO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_transmit_sdo_pack(
    uint8_t *dst_p,
    const struct can1_res_transmit_sdo_t *src_p,
    size_t size);

/**
 * Unpack message res_transmit_SDO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_transmit_sdo_unpack(
    struct can1_res_transmit_sdo_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from res_transmit_SDO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_res_transmit_sdo_init(struct can1_res_transmit_sdo_t *msg_p);

/**
 * Pack message res_recieve_SDO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_recieve_sdo_pack(
    uint8_t *dst_p,
    const struct can1_res_recieve_sdo_t *src_p,
    size_t size);

/**
 * Unpack message res_recieve_SDO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_recieve_sdo_unpack(
    struct can1_res_recieve_sdo_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from res_recieve_SDO.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_res_recieve_sdo_init(struct can1_res_recieve_sdo_t *msg_p);

/**
 * Pack message res_transmit_LSS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_transmit_lss_pack(
    uint8_t *dst_p,
    const struct can1_res_transmit_lss_t *src_p,
    size_t size);

/**
 * Unpack message res_transmit_LSS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_transmit_lss_unpack(
    struct can1_res_transmit_lss_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from res_transmit_LSS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_res_transmit_lss_init(struct can1_res_transmit_lss_t *msg_p);

/**
 * Pack message res_recieve_LSS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_recieve_lss_pack(
    uint8_t *dst_p,
    const struct can1_res_recieve_lss_t *src_p,
    size_t size);

/**
 * Unpack message res_recieve_LSS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_recieve_lss_unpack(
    struct can1_res_recieve_lss_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from res_recieve_LSS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_res_recieve_lss_init(struct can1_res_recieve_lss_t *msg_p);

/**
 * Pack message AMS_parameters_set.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_parameters_set_pack(
    uint8_t *dst_p,
    const struct can1_ams_parameters_set_t *src_p,
    size_t size);

/**
 * Unpack message AMS_parameters_set.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_parameters_set_unpack(
    struct can1_ams_parameters_set_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AMS_parameters_set.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ams_parameters_set_init(struct can1_ams_parameters_set_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_parameters_set_cell_under_voltage_treshold_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_parameters_set_cell_under_voltage_treshold_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_parameters_set_cell_under_voltage_treshold_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_parameters_set_cell_over_voltage_treshold_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_parameters_set_cell_over_voltage_treshold_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_parameters_set_cell_over_voltage_treshold_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_parameters_set_voltage_time_constraint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_parameters_set_voltage_time_constraint_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_parameters_set_voltage_time_constraint_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_parameters_set_temperature_time_constraint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_parameters_set_temperature_time_constraint_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_parameters_set_temperature_time_constraint_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_parameters_set_current_time_constraint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_parameters_set_current_time_constraint_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_parameters_set_current_time_constraint_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_parameters_set_voltage_drive_lower_bound_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_parameters_set_voltage_drive_lower_bound_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_parameters_set_voltage_drive_lower_bound_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_parameters_set_voltage_lower_bound_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_parameters_set_voltage_lower_bound_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_parameters_set_voltage_lower_bound_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_parameters_set_start_balancing_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_parameters_set_start_balancing_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_parameters_set_start_balancing_is_in_range(uint8_t value);

/**
 * Pack message IVT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ivt_pack(
    uint8_t *dst_p,
    const struct can1_ivt_t *src_p,
    size_t size);

/**
 * Unpack message IVT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ivt_unpack(
    struct can1_ivt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IVT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ivt_init(struct can1_ivt_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ivt_u3_accumulator_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_u3_accumulator_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_u3_accumulator_voltage_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ivt_u2_fuse_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_u2_fuse_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_u2_fuse_voltage_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ivt_u1_ts_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_u1_ts_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_u1_ts_voltage_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ivt_i_accumulator_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_i_accumulator_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_i_accumulator_current_is_in_range(int16_t value);

/**
 * Pack message IVT_extra.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ivt_extra_pack(
    uint8_t *dst_p,
    const struct can1_ivt_extra_t *src_p,
    size_t size);

/**
 * Unpack message IVT_extra.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ivt_extra_unpack(
    struct can1_ivt_extra_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IVT_extra.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_ivt_extra_init(struct can1_ivt_extra_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ivt_extra_as_ivt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_extra_as_ivt_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_extra_as_ivt_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ivt_extra_t_ivt_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_extra_t_ivt_time_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_extra_t_ivt_time_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ivt_extra_w_ivt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_extra_w_ivt_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_extra_w_ivt_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ivt_extra_wh_ivt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ivt_extra_wh_ivt_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ivt_extra_wh_ivt_is_in_range(int16_t value);

/**
 * Pack message vehicle_status_wheel_velocities.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vehicle_status_wheel_velocities_pack(
    uint8_t *dst_p,
    const struct can1_vehicle_status_wheel_velocities_t *src_p,
    size_t size);

/**
 * Unpack message vehicle_status_wheel_velocities.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vehicle_status_wheel_velocities_unpack(
    struct can1_vehicle_status_wheel_velocities_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vehicle_status_wheel_velocities.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vehicle_status_wheel_velocities_init(struct can1_vehicle_status_wheel_velocities_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_velocities_wheel_velocity_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_velocities_wheel_velocity_fl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_velocities_wheel_velocity_fl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_velocities_wheel_velocity_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_velocities_wheel_velocity_fr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_velocities_wheel_velocity_fr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_velocities_wheel_velocity_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_velocities_wheel_velocity_rl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_velocities_wheel_velocity_rl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_velocities_wheel_velocity_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_velocities_wheel_velocity_rr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_velocities_wheel_velocity_rr_is_in_range(int16_t value);

/**
 * Pack message dv_control_target_TV.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_control_target_tv_pack(
    uint8_t *dst_p,
    const struct can1_dv_control_target_tv_t *src_p,
    size_t size);

/**
 * Unpack message dv_control_target_TV.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_control_target_tv_unpack(
    struct can1_dv_control_target_tv_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from dv_control_target_TV.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_dv_control_target_tv_init(struct can1_dv_control_target_tv_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dv_control_target_tv_dv_fl_speedd_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_tv_dv_fl_speedd_target_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_tv_dv_fl_speedd_target_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dv_control_target_tv_dv_fr_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_tv_dv_fr_speed_target_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_tv_dv_fr_speed_target_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dv_control_target_tv_dv_rl_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_tv_dv_rl_speed_target_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_tv_dv_rl_speed_target_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dv_control_target_tv_dv_rr_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_tv_dv_rr_speed_target_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_tv_dv_rr_speed_target_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dv_control_target_tv_dv_steering_angle_target_tv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_tv_dv_steering_angle_target_tv_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_tv_dv_steering_angle_target_tv_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_control_target_tv_dv_mission_status_tv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_tv_dv_mission_status_tv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_tv_dv_mission_status_tv_is_in_range(uint8_t value);

/**
 * Pack message vmu_gpio.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vmu_gpio_pack(
    uint8_t *dst_p,
    const struct can1_vmu_gpio_t *src_p,
    size_t size);

/**
 * Unpack message vmu_gpio.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vmu_gpio_unpack(
    struct can1_vmu_gpio_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vmu_gpio.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vmu_gpio_init(struct can1_vmu_gpio_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vmu_gpio_msgs_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_gpio_msgs_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_gpio_msgs_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vmu_gpio_gpio_configuration_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_gpio_gpio_configuration_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_gpio_gpio_configuration_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vmu_gpio_io1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_gpio_io1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_gpio_io1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vmu_gpio_io2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_gpio_io2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_gpio_io2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vmu_gpio_io3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_gpio_io3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_gpio_io3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vmu_gpio_io4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_gpio_io4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_gpio_io4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vmu_gpio_io5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_gpio_io5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_gpio_io5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vmu_gpio_io6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_gpio_io6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_gpio_io6_is_in_range(uint8_t value);

/**
 * Pack message res_sync.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_sync_pack(
    uint8_t *dst_p,
    const struct can1_res_sync_t *src_p,
    size_t size);

/**
 * Unpack message res_sync.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_sync_unpack(
    struct can1_res_sync_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from res_sync.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_res_sync_init(struct can1_res_sync_t *msg_p);

/**
 * Pack message res_emergency.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_emergency_pack(
    uint8_t *dst_p,
    const struct can1_res_emergency_t *src_p,
    size_t size);

/**
 * Unpack message res_emergency.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_emergency_unpack(
    struct can1_res_emergency_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from res_emergency.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_res_emergency_init(struct can1_res_emergency_t *msg_p);

/**
 * Pack message res_timestamp.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_timestamp_pack(
    uint8_t *dst_p,
    const struct can1_res_timestamp_t *src_p,
    size_t size);

/**
 * Unpack message res_timestamp.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_timestamp_unpack(
    struct can1_res_timestamp_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from res_timestamp.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_res_timestamp_init(struct can1_res_timestamp_t *msg_p);

/**
 * Pack message dv_info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_info_pack(
    uint8_t *dst_p,
    const struct can1_dv_info_t *src_p,
    size_t size);

/**
 * Unpack message dv_info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_info_unpack(
    struct can1_dv_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from dv_info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_dv_info_init(struct can1_dv_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dv_info_yaw_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_info_yaw_rate_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_info_yaw_rate_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_info_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_info_speed_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_info_speed_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_info_lap_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_info_lap_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_info_lap_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_info_cones_count_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_info_cones_count_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_info_cones_count_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_info_cones_count_all_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_info_cones_count_all_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_info_cones_count_all_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_info_acceleration_longitudinal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_info_acceleration_longitudinal_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_info_acceleration_longitudinal_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_info_acceleration_lateral_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_info_acceleration_lateral_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_info_acceleration_lateral_is_in_range(int8_t value);

/**
 * Pack message vehicle_status_motor_torques.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vehicle_status_motor_torques_pack(
    uint8_t *dst_p,
    const struct can1_vehicle_status_motor_torques_t *src_p,
    size_t size);

/**
 * Unpack message vehicle_status_motor_torques.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vehicle_status_motor_torques_unpack(
    struct can1_vehicle_status_motor_torques_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vehicle_status_motor_torques.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vehicle_status_motor_torques_init(struct can1_vehicle_status_motor_torques_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_motor_torques_torque_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_motor_torques_torque_fl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_motor_torques_torque_fl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_motor_torques_torque_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_motor_torques_torque_fr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_motor_torques_torque_fr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_motor_torques_torque_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_motor_torques_torque_rl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_motor_torques_torque_rl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_motor_torques_torque_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_motor_torques_torque_rr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_motor_torques_torque_rr_is_in_range(int16_t value);

/**
 * Pack message vehicle_status_motor_temp.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vehicle_status_motor_temp_pack(
    uint8_t *dst_p,
    const struct can1_vehicle_status_motor_temp_t *src_p,
    size_t size);

/**
 * Unpack message vehicle_status_motor_temp.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vehicle_status_motor_temp_unpack(
    struct can1_vehicle_status_motor_temp_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vehicle_status_motor_temp.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vehicle_status_motor_temp_init(struct can1_vehicle_status_motor_temp_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_motor_temp_motor_temp_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_motor_temp_motor_temp_fr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_motor_temp_motor_temp_fr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_motor_temp_motor_temp_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_motor_temp_motor_temp_fl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_motor_temp_motor_temp_fl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_motor_temp_motor_temp_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_motor_temp_motor_temp_rr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_motor_temp_motor_temp_rr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_motor_temp_motor_temp_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_motor_temp_motor_temp_rl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_motor_temp_motor_temp_rl_is_in_range(int16_t value);

/**
 * Pack message vehicle_status_inverter_temp.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vehicle_status_inverter_temp_pack(
    uint8_t *dst_p,
    const struct can1_vehicle_status_inverter_temp_t *src_p,
    size_t size);

/**
 * Unpack message vehicle_status_inverter_temp.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vehicle_status_inverter_temp_unpack(
    struct can1_vehicle_status_inverter_temp_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vehicle_status_inverter_temp.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vehicle_status_inverter_temp_init(struct can1_vehicle_status_inverter_temp_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_inverter_temp_inverter_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_inverter_temp_inverter_rr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_inverter_temp_inverter_rr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_inverter_temp_inverter_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_inverter_temp_inverter_rl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_inverter_temp_inverter_rl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_inverter_temp_inverter_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_inverter_temp_inverter_fr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_inverter_temp_inverter_fr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_inverter_temp_inverter_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_inverter_temp_inverter_fl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_inverter_temp_inverter_fl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_inverter_temp_igtb_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_inverter_temp_igtb_rr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_inverter_temp_igtb_rr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_inverter_temp_igtb_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_inverter_temp_igtb_rl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_inverter_temp_igtb_rl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_inverter_temp_igtb_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_inverter_temp_igtb_fr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_inverter_temp_igtb_fr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_inverter_temp_igtb_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_inverter_temp_igtb_fl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_inverter_temp_igtb_fl_is_in_range(uint8_t value);

/**
 * Pack message vehicle_status_pedals.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vehicle_status_pedals_pack(
    uint8_t *dst_p,
    const struct can1_vehicle_status_pedals_t *src_p,
    size_t size);

/**
 * Unpack message vehicle_status_pedals.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vehicle_status_pedals_unpack(
    struct can1_vehicle_status_pedals_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vehicle_status_pedals.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vehicle_status_pedals_init(struct can1_vehicle_status_pedals_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_pedals_normalized_brake_pedal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_pedals_normalized_brake_pedal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_pedals_normalized_brake_pedal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_pedals_normalized_acceleration_pedal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_pedals_normalized_acceleration_pedal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_pedals_normalized_acceleration_pedal_is_in_range(uint8_t value);

/**
 * Pack message amk1_setpoints_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_amk1_setpoints_1_pack(
    uint8_t *dst_p,
    const struct can1_amk1_setpoints_1_t *src_p,
    size_t size);

/**
 * Unpack message amk1_setpoints_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_amk1_setpoints_1_unpack(
    struct can1_amk1_setpoints_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from amk1_setpoints_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_amk1_setpoints_1_init(struct can1_amk1_setpoints_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk1_setpoints_1_amk1_control_inverter_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk1_setpoints_1_amk1_control_inverter_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk1_setpoints_1_amk1_control_inverter_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk1_setpoints_1_amk1_control_dc_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk1_setpoints_1_amk1_control_dc_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk1_setpoints_1_amk1_control_dc_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk1_setpoints_1_amk1_control_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk1_setpoints_1_amk1_control_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk1_setpoints_1_amk1_control_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk1_setpoints_1_amk1_control_error_reset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk1_setpoints_1_amk1_control_error_reset_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk1_setpoints_1_amk1_control_error_reset_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_amk1_setpoints_1_amk1_target_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk1_setpoints_1_amk1_target_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk1_setpoints_1_amk1_target_velocity_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_amk1_setpoints_1_amk1_torque_limit_positiv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk1_setpoints_1_amk1_torque_limit_positiv_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk1_setpoints_1_amk1_torque_limit_positiv_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_amk1_setpoints_1_amk1_torque_limit_negativ_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk1_setpoints_1_amk1_torque_limit_negativ_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk1_setpoints_1_amk1_torque_limit_negativ_is_in_range(int16_t value);

/**
 * Pack message amk2_setpoints_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_amk2_setpoints_1_pack(
    uint8_t *dst_p,
    const struct can1_amk2_setpoints_1_t *src_p,
    size_t size);

/**
 * Unpack message amk2_setpoints_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_amk2_setpoints_1_unpack(
    struct can1_amk2_setpoints_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from amk2_setpoints_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_amk2_setpoints_1_init(struct can1_amk2_setpoints_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk2_setpoints_1_amk2_control_inverter_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk2_setpoints_1_amk2_control_inverter_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk2_setpoints_1_amk2_control_inverter_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk2_setpoints_1_amk2_control_dc_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk2_setpoints_1_amk2_control_dc_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk2_setpoints_1_amk2_control_dc_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk2_setpoints_1_amk2_control_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk2_setpoints_1_amk2_control_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk2_setpoints_1_amk2_control_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk2_setpoints_1_amk2_control_error_reset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk2_setpoints_1_amk2_control_error_reset_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk2_setpoints_1_amk2_control_error_reset_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_amk2_setpoints_1_amk2_target_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk2_setpoints_1_amk2_target_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk2_setpoints_1_amk2_target_velocity_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_amk2_setpoints_1_amk2_torque_limit_positiv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk2_setpoints_1_amk2_torque_limit_positiv_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk2_setpoints_1_amk2_torque_limit_positiv_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_amk2_setpoints_1_amk2_torque_limit_negativ_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk2_setpoints_1_amk2_torque_limit_negativ_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk2_setpoints_1_amk2_torque_limit_negativ_is_in_range(int16_t value);

/**
 * Pack message amk3_setpoints_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_amk3_setpoints_1_pack(
    uint8_t *dst_p,
    const struct can1_amk3_setpoints_1_t *src_p,
    size_t size);

/**
 * Unpack message amk3_setpoints_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_amk3_setpoints_1_unpack(
    struct can1_amk3_setpoints_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from amk3_setpoints_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_amk3_setpoints_1_init(struct can1_amk3_setpoints_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk3_setpoints_1_amk3_control_inverter_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk3_setpoints_1_amk3_control_inverter_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk3_setpoints_1_amk3_control_inverter_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk3_setpoints_1_amk3_control_dc_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk3_setpoints_1_amk3_control_dc_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk3_setpoints_1_amk3_control_dc_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk3_setpoints_1_amk3_control_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk3_setpoints_1_amk3_control_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk3_setpoints_1_amk3_control_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk3_setpoints_1_amk3_control_error_reset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk3_setpoints_1_amk3_control_error_reset_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk3_setpoints_1_amk3_control_error_reset_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_amk3_setpoints_1_amk3_target_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk3_setpoints_1_amk3_target_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk3_setpoints_1_amk3_target_velocity_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_amk3_setpoints_1_amk3_torque_limit_positiv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk3_setpoints_1_amk3_torque_limit_positiv_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk3_setpoints_1_amk3_torque_limit_positiv_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_amk3_setpoints_1_amk3_torque_limit_negativ_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk3_setpoints_1_amk3_torque_limit_negativ_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk3_setpoints_1_amk3_torque_limit_negativ_is_in_range(int16_t value);

/**
 * Pack message amk4_setpoints_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_amk4_setpoints_1_pack(
    uint8_t *dst_p,
    const struct can1_amk4_setpoints_1_t *src_p,
    size_t size);

/**
 * Unpack message amk4_setpoints_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_amk4_setpoints_1_unpack(
    struct can1_amk4_setpoints_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from amk4_setpoints_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_amk4_setpoints_1_init(struct can1_amk4_setpoints_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk4_setpoints_1_amk4_control_inverter_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk4_setpoints_1_amk4_control_inverter_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk4_setpoints_1_amk4_control_inverter_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk4_setpoints_1_amk4_control_dc_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk4_setpoints_1_amk4_control_dc_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk4_setpoints_1_amk4_control_dc_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk4_setpoints_1_amk4_control_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk4_setpoints_1_amk4_control_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk4_setpoints_1_amk4_control_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_amk4_setpoints_1_amk4_control_error_reset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk4_setpoints_1_amk4_control_error_reset_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk4_setpoints_1_amk4_control_error_reset_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_amk4_setpoints_1_amk4_target_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk4_setpoints_1_amk4_target_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk4_setpoints_1_amk4_target_velocity_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_amk4_setpoints_1_amk4_torque_limit_positiv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk4_setpoints_1_amk4_torque_limit_positiv_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk4_setpoints_1_amk4_torque_limit_positiv_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_amk4_setpoints_1_amk4_torque_limit_negativ_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_amk4_setpoints_1_amk4_torque_limit_negativ_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_amk4_setpoints_1_amk4_torque_limit_negativ_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_TRACK_SLIP_CURVATUR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_track_slip_curvatur_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_track_slip_curvatur_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_TRACK_SLIP_CURVATUR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_track_slip_curvatur_unpack(
    struct can1_sbg_ecan_msg_track_slip_curvatur_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SBG_ECAN_MSG_TRACK_SLIP_CURVATUR.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_sbg_ecan_msg_track_slip_curvatur_init(struct can1_sbg_ecan_msg_track_slip_curvatur_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_track_slip_curvatur_angle_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_track_slip_curvatur_angle_track_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_track_slip_curvatur_angle_track_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_track_slip_curvatur_angle_slip_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_track_slip_curvatur_angle_slip_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_track_slip_curvatur_angle_slip_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_track_slip_curvatur_curvature_radius_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_track_slip_curvatur_curvature_radius_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_track_slip_curvatur_curvature_radius_is_in_range(uint16_t value);

/**
 * Pack message Slip_sensor.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_slip_sensor_pack(
    uint8_t *dst_p,
    const struct can1_slip_sensor_t *src_p,
    size_t size);

/**
 * Unpack message Slip_sensor.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_slip_sensor_unpack(
    struct can1_slip_sensor_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Slip_sensor.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_slip_sensor_init(struct can1_slip_sensor_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_slip_sensor_speed_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_slip_sensor_speed_y_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_slip_sensor_speed_y_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_slip_sensor_speed_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_slip_sensor_speed_x_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_slip_sensor_speed_x_is_in_range(uint32_t value);

/**
 * Pack message jon_slip.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_jon_slip_pack(
    uint8_t *dst_p,
    const struct can1_jon_slip_t *src_p,
    size_t size);

/**
 * Unpack message jon_slip.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_jon_slip_unpack(
    struct can1_jon_slip_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from jon_slip.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_jon_slip_init(struct can1_jon_slip_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_jon_slip_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_jon_slip_x_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_jon_slip_x_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_jon_slip_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_jon_slip_y_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_jon_slip_y_is_in_range(uint16_t value);

/**
 * Pack message vehicle_status_accumulator_soc.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vehicle_status_accumulator_soc_pack(
    uint8_t *dst_p,
    const struct can1_vehicle_status_accumulator_soc_t *src_p,
    size_t size);

/**
 * Unpack message vehicle_status_accumulator_soc.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vehicle_status_accumulator_soc_unpack(
    struct can1_vehicle_status_accumulator_soc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from vehicle_status_accumulator_soc.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can1_vehicle_status_accumulator_soc_init(struct can1_vehicle_status_accumulator_soc_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_vehicle_status_accumulator_soc_soc_cc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_accumulator_soc_soc_cc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_accumulator_soc_soc_cc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_vehicle_status_accumulator_soc_soc_kalman_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_accumulator_soc_soc_kalman_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_accumulator_soc_soc_kalman_is_in_range(uint16_t value);


#ifdef __cplusplus
}
#endif

#endif
